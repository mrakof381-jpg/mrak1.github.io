<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>FlashChat Pro — Мессенджер нового поколения</title>
  <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
  <!-- Firebase compat -->
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-storage-compat.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#0b1220;
      --panel:#0f172a;
      --panel2:#111827;
      --card:rgba(31,41,55,.6);
      --border:rgba(148,163,184,.15);
      --muted:#9ca3af;
      --text:#e5e7eb;
      --purple:#8b5cf6;
      --blue:#60a5fa;
    }
    *{ box-sizing:border-box; font-family:Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif; -webkit-tap-highlight-color:transparent; }
    html,body{ height:100%; margin:0; padding:0; }
    body{
      background:var(--bg);
      color:var(--text);
      overflow:hidden;
      height:100vh;
      height:100svh;
      height:100dvh;
    }
    .gradient-bg{ background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
    .gradient-green{ background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); }
    .gradient-orange{ background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); }
    .glass{ background: rgba(255,255,255,.06); backdrop-filter: blur(14px); }
    /* App shell */
    #appShell{
      position:fixed;
      inset:0;
      display:flex;
      flex-direction:column;
      height:100vh;
      height:100svh;
      height:100dvh;
      overflow:hidden;
    }
    #authScreen{ position:absolute; inset:0; overflow:auto; -webkit-overflow-scrolling:touch; }
    #chatScreen{ position:absolute; inset:0; display:none; }
    #chatScreen.active{ display:flex; }
    /* === RESPONSIVE LAYOUT === */
    /* Desktop (>1200px) */
    #sidebar{
      width:380px;
      min-width:320px;
      max-width:420px;
      display:flex;
      flex-direction:column;
      height:100%;
      border-right:1px solid var(--border);
      background:rgba(15, 23, 42, .55);
    }
    #chatArea{
      flex:1 1 auto;
      min-width:0;
      display:flex;
      flex-direction:column;
      height:100%;
      background:rgba(2,6,23,.35);
    }
    /* Tablet (769px - 1200px) */
    @media (min-width: 769px) and (max-width: 1200px){
      #sidebar{ width:320px; min-width:280px; max-width:350px; }
    }
    /* Mobile (<=768px) */
    @media (max-width: 768px){
      #chatScreen.active{ display:block; }
      #sidebar, #chatArea{
        position:absolute;
        inset:0;
        width:100%;
        max-width:none;
        min-width:0;
        height:100%;
        height:100svh;
        height:100dvh;
      }
      #sidebar{ display:flex; }
      #chatArea{ display:none; }
      #chatArea.active{ display:flex; }
    }
    @supports (height: -webkit-fill-available){
      body{ height: -webkit-fill-available; }
      #appShell{ height: -webkit-fill-available; }
    }
    /* Sidebar internals */
    #chatList{ flex:1 1 auto; min-height:0; overflow:auto; -webkit-overflow-scrolling:touch; }
    #searchResults{ max-height: 40vh; overflow:auto; }
    /* Chat area internals */
    #emptyChat{ flex:1 1 auto; display:flex; align-items:center; justify-content:center; padding:24px; }
    #activeChat{ flex:1 1 auto; min-height:0; display:none; flex-direction:column; overflow:hidden; }
    #activeChat.active{ display:flex; }
    .chat-header{ flex:0 0 auto; border-bottom:1px solid var(--border); background:rgba(15, 23, 42, .85); }
    #messagesContainer{
      flex:1 1 auto;
      min-height:0;
      overflow:auto;
      -webkit-overflow-scrolling:touch;
      padding:16px;
      padding-bottom:20px;
    }
    #typingIndicator{ flex:0 0 auto; }
    #uploadPreview{ flex:0 0 auto; }
    /* Input pinned */
    #messageInputArea{
      flex:0 0 auto;
      border-top:1px solid var(--border);
      background:rgba(15, 23, 42, .92);
      padding:10px;
      padding-bottom:max(10px, env(safe-area-inset-bottom));
    }
    #messageForm{ display:flex; align-items:center; gap:8px; }
    #messageInput{
      flex:1 1 auto;
      min-width:0;
      height:44px;
      border-radius:14px;
      border:1px solid rgba(148,163,184,.25);
      background:rgba(31,41,55,.5);
      color:white;
      padding:0 14px;
      font-size:15px;
      outline:none;
    }
    #messageInput:focus{ border-color: rgba(139,92,246,.9); box-shadow: 0 0 0 3px rgba(139,92,246,.15); }
    .icon-btn{
      width:44px; height:44px;
      display:grid; place-items:center;
      border-radius:14px;
      border:1px solid rgba(148,163,184,.18);
      background:rgba(31,41,55,.25);
      color:#cbd5e1;
      flex:0 0 auto;
      cursor:pointer;
      transition: all .15s;
    }
    .icon-btn:hover{ background:rgba(31,41,55,.45); color:white; }
    .send-btn{
      width:44px; height:44px;
      display:grid; place-items:center;
      border-radius:14px;
      border:none;
      color:white;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      box-shadow: 0 8px 20px rgba(102,126,234,.28);
      flex:0 0 auto;
      cursor:pointer;
      transition: opacity .15s;
    }
    .send-btn:hover{ opacity:.92; }
    /* Scrollbars */
    .scrollbar::-webkit-scrollbar{ width:6px; height:6px; }
    .scrollbar::-webkit-scrollbar-thumb{ background: rgba(148,163,184,.25); border-radius:999px; }
    .scrollbar::-webkit-scrollbar-track{ background: transparent; }
    /* === MESSAGES - RESPONSIVE (TG-like bubbles) === */
    .message-row{ display:flex; width:100%; margin-bottom:6px; }
    .message-row.out{ justify-content:flex-end; }
    .message-row.in{ justify-content:flex-start; }
    /*
      IMPORTANT:
      На некоторых браузерах (особенно Safari) "ранний перенос" случается,
      когда обёртка сообщения сжимается по содержимому, а max-width в % считается
      от этой маленькой ширины. Поэтому обёртка должна быть width:100%.
    */
    .message-row > div{
      width:100%;
      display:flex;
      flex-direction:column;
      min-width:0;
      max-width:100%;
    }
    /* keep outgoing bubbles aligned to the right (as before) */
    .message-row.out > div{ align-items:flex-end; }
    .message-row.in > div{ align-items:flex-start; }
    /* Bubble: не задаём width:fit-content, чтобы избежать странностей с расчётом ширины в flex.
       Inline-block сам сожмётся по контенту, а max-width ограничит длинные сообщения. */
    .bubble{
      display:inline-block;
      max-width: 72%;
      border-radius:18px;
      padding:10px 14px;
      position:relative;
      overflow:hidden;
      text-align:left;
      white-space: normal;
      /* не ломаем слова «раньше времени» */
      overflow-wrap: normal;
      word-break: normal;
      hyphens: manual;
    }
    .bubble.out{ background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-top-right-radius:6px; }
    .bubble.in{ background: rgba(31,41,55,.75); border-top-left-radius:6px; border:1px solid rgba(148,163,184,.12); }
    /* Tablet bubbles */
    @media (min-width: 769px) and (max-width: 1200px){
      .bubble{ max-width: 78%; }
    }
    /* Mobile bubbles */
    @media (max-width: 768px){
      .bubble{ max-width: 88%; padding: 8px 12px; }
      #messagesContainer{ padding: 10px; }
    }
    /* Small phones */
    @media (max-width: 400px){
      .bubble{ max-width: 92%; padding: 7px 10px; font-size: 14px; }
      #messagesContainer{ padding: 8px; }
    }
    .msg-wrap{ width:100%; min-width:0; max-width:100%; display:flex; flex-direction:column; }
    .sender-line{ font-size:12px; color: rgba(167,139,250, .95); margin: 0 0 6px 2px; display:flex; align-items:center; gap:6px; }
    /* Prevent time/checks from wrapping and causing bubble width jumps */
    .meta{ display:flex; justify-content:flex-end; align-items:center; gap:6px; margin-top:6px; white-space:nowrap; }
    .meta .time{ font-size:11px; color: rgba(255,255,255,.75); }
    .bubble.in .meta .time{ color: rgba(148,163,184,.85); }
    /* === MEDIA IN MESSAGES - RESPONSIVE === */
    .message-media{
      border-radius:12px;
      overflow:hidden;
      border:1px solid rgba(148,163,184,.18);
      background:rgba(2,6,23,.45);
      display:inline-block; /* don't stretch the bubble */
      width: fit-content;
      max-width: 100%;
    }
    .message-media img, .message-media video{
      display:block;
      width:auto;
      height:auto;
      max-width:100%;
      max-height:400px;
      object-fit:contain;
      background:black;
      cursor:pointer;
    }
    /* Desktop media */
    @media (min-width: 1201px){
      .message-media img, .message-media video{ max-width: 400px; max-height: 450px; }
    }
    /* Tablet media */
    @media (min-width: 769px) and (max-width: 1200px){
      .message-media img, .message-media video{ max-width: 320px; max-height: 380px; }
    }
    /* Mobile media */
    @media (max-width: 768px){
      .message-media img, .message-media video{ max-width: 280px; max-height: 350px; }
    }
    /* Small phones media */
    @media (max-width: 400px){
      .message-media img, .message-media video{ max-width: 220px; max-height: 280px; }
      .message-media{ border-radius: 10px; }
    }
    .msg-text{
      font-size: 14px;
      line-height: 1.4;
      max-width: 100%;
      min-width: 0;
      /* обычное поведение как в Telegram: короткие слова не ломаем */
      white-space: pre-wrap;
      word-break: normal;
      overflow-wrap: break-word; /* переносим только если слово/URL реально не помещается */
      hyphens: manual;
    }
    .media-caption{ margin-top: 6px; }
    .bubble .text-sm{ line-height: 1.4; }
    .file-chip{
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px;
      border-radius:14px;
      background:rgba(15,23,42,.45);
      border:1px solid rgba(148,163,184,.15);
      max-width: 100%;
      min-width: 0;
    }
    .file-chip *{ min-width:0; }
    .file-chip .min-w-0{ min-width: 0; }
    /* Voice message styles */
    .voice-message{
      display:flex;
      align-items:center;
      gap:10px;
      padding:8px 12px;
      border-radius:18px;
      background:rgba(15,23,42,.35);
      border:1px solid rgba(148,163,184,.12);
      max-width:280px;
      min-width:200px;
    }
    .bubble.out .voice-message{
      background:rgba(255,255,255,.1);
      border-color:rgba(255,255,255,.15);
    }
    .voice-play-btn{
      width:36px;
      height:36px;
      border-radius:50%;
      background:rgba(139,92,246,.85);
      border:none;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      flex-shrink:0;
      transition:all .15s;
    }
    .voice-play-btn:hover{
      background:rgba(139,92,246,1);
      transform:scale(1.05);
    }
    .voice-play-btn svg{
      width:16px;
      height:16px;
      color:white;
    }
    .voice-waveform{
      flex:1;
      height:32px;
      display:flex;
      align-items:center;
      gap:2px;
      min-width:0;
    }
    .voice-bar{
      flex:1;
      min-width:2px;
      background:rgba(139,92,246,.4);
      border-radius:2px;
      transition:all .2s;
    }
    .voice-bar.active{
      background:rgba(139,92,246,.9);
    }
    .bubble.out .voice-bar{
      background:rgba(255,255,255,.3);
    }
    .bubble.out .voice-bar.active{
      background:rgba(255,255,255,.8);
    }
    .voice-duration{
      font-size:12px;
      color:rgba(148,163,184,.85);
      white-space:nowrap;
      flex-shrink:0;
    }
    .bubble.out .voice-duration{
      color:rgba(255,255,255,.75);
    }
    /* Recording indicator */
    .recording-indicator{
      display:flex;
      align-items:center;
      gap:8px;
      padding:8px 12px;
      background:rgba(239,68,68,.15);
      border:1px solid rgba(239,68,68,.3);
      border-radius:12px;
      color:#f87171;
      font-size:14px;
    }
    .recording-dot{
      width:8px;
      height:8px;
      background:#ef4444;
      border-radius:50%;
      animation:pulse 1.5s infinite;
    }
    @keyframes pulse{
      0%,100%{ opacity:1; transform:scale(1); }
      50%{ opacity:.5; transform:scale(1.2); }
    }
    /* Safety: nothing inside bubble should force bubble to grow wider than max-width */
    .bubble > *{ max-width:100%; }
    @media (max-width: 768px){
      .file-chip{ padding: 8px; gap: 8px; border-radius: 12px; }
      .file-chip svg{ width: 24px; height: 24px; }
    }
    /* Typing indicator */
    .typing-dot{ width:7px; height:7px; background:rgba(148,163,184,.9); border-radius:999px; display:inline-block; animation:typing 1.2s infinite; }
    .typing-dot:nth-child(2){ animation-delay:.15s; }
    .typing-dot:nth-child(3){ animation-delay:.3s; }
    @keyframes typing{ 0%,60%,100%{ transform:translateY(0); opacity:.7 } 30%{ transform:translateY(-4px); opacity:1 } }
    /* Toast */
    #toast{ position:fixed; top:14px; left:14px; right:14px; max-width:520px; margin:0 auto; z-index:80; }
    /* Modals */
    .modal{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; padding:16px; z-index:70; background:rgba(0,0,0,.65); backdrop-filter: blur(6px); }
    .modal.show{ display:flex; }
    .sheet{ width:100%; max-width:520px; border-radius:22px; border:1px solid rgba(148,163,184,.18); background:rgba(15,23,42,.95); box-shadow: 0 18px 60px rgba(0,0,0,.45); overflow:hidden; max-height: 90vh; overflow-y: auto; }
    @media (max-width:768px){
      .modal{ padding: 10px; }
      .sheet{ max-width: 100%; border-radius: 20px; max-height: 85vh; }
      .sheet.bottom{ align-self:flex-end; border-bottom-left-radius:0; border-bottom-right-radius:0; }
    }
    /* Emoji picker */
    #emojiPicker{ display:none; margin-top:10px; border-radius:16px; border:1px solid rgba(148,163,184,.15); overflow:hidden; background:rgba(15,23,42,.85); }
    #emojiPicker.show{ display:block; }
    .emoji-tabs{ display:flex; border-bottom:1px solid rgba(148,163,184,.12); overflow-x:auto; }
    .emoji-tab{ flex:1; min-width:40px; padding:10px 0; text-align:center; font-size:18px; color:#cbd5e1; border-bottom:2px solid transparent; background:rgba(2,6,23,.18); }
    .emoji-tab.active{ border-bottom-color: rgba(139,92,246,.9); color:white; }
    .emoji-grid{ padding:10px; max-height:200px; overflow:auto; display:grid; grid-template-columns: repeat(8, 1fr); gap:6px; }
    .emoji-btn{
      border-radius:8px;
      padding:8px;
      font-size:20px;
      line-height:1;
      cursor:pointer;
      border:1px solid rgba(148,163,184,.15);
      background:rgba(2,6,23,.3);
      transition: all 0.15s ease;
    }
    .emoji-btn:hover{
      background:rgba(139,92,246,.2);
      border-color:rgba(139,92,246,.4);
      transform: scale(1.1);
    }
    @media (max-width: 768px){
      .emoji-grid{ grid-template-columns: repeat(7, 1fr); max-height: 180px; gap:5px; }
      .emoji-btn{ font-size: 22px; padding: 8px; }
    }
    @media (max-width: 400px){
      .emoji-grid{ grid-template-columns: repeat(6, 1fr); gap:4px; }
      .emoji-btn{ padding: 6px; }
    }
    /* Developer badge */
    .dev-badge{
      display:inline-flex;
      align-items:center;
      gap:4px;
      padding:2px 7px;
      border-radius:999px;
      font-size:10px;
      font-weight:700;
      letter-spacing:.6px;
      color:white;
      background: linear-gradient(135deg,#f093fb 0%, #f5576c 100%);
      border:1px solid rgba(255,255,255,.18);
      vertical-align:middle;
      white-space:nowrap;
    }
    .dev-badge svg{ width:12px; height:12px; }
    /* Message context menu */
    #messageContextMenu{ position:fixed; display:none; z-index:75; border-radius:16px; background:rgba(15,23,42,.95); border:1px solid rgba(148,163,184,.18); box-shadow: 0 14px 40px rgba(0,0,0,.45); min-width: 180px; max-width: calc(100vw - 20px); overflow:hidden; }
    #messageContextMenu.show{ display:block; }
    #messageContextMenu.bottom-sheet{ left:10px !important; right:10px !important; top:auto !important; bottom:max(12px, env(safe-area-inset-bottom)) !important; width:auto; max-width:520px; margin:0 auto; border-radius:20px; animation: slideUp .18s ease; }
    @keyframes slideUp{ from{ transform: translateY(12px); opacity:0;} to{ transform: translateY(0); opacity:1;} }
    @media (max-width:768px){ #messageContextMenu{ min-width:0; } }
    #messageContextMenu.show{ display:block; }
    .context-menu-btn{ width:100%; display:flex; align-items:center; gap:10px; padding:12px 16px; border:none; background:transparent; color:#e5e7eb; cursor:pointer; font-size:14px; transition: background .15s; }
    .context-menu-btn:hover{ background:rgba(148,163,184,.12); }
    .context-menu-btn.text-red-400{ color:#f87171; }
    .context-menu-btn.text-red-400:hover{ background:rgba(248,113,113,.12); }
    .context-menu-divider{ height:1px; background:rgba(148,163,184,.15); margin:4px 0; }
    /* Reaction picker */
    .reaction-btn{ font-size:22px; padding:6px; border-radius:12px; border:none; background:transparent; cursor:pointer; transition: transform .15s; }
    .reaction-btn:hover{ background:rgba(148,163,184,.12); transform:scale(1.15); }
    /* Edited message indicator */
    .edited-indicator{ font-size:11px; color:rgba(148,163,184,.7); font-style:italic; }
    /* Image viewer */
    #imageViewer{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:90; background:rgba(0,0,0,.95); padding:16px; }
    #imageViewer.show{ display:flex; }
    #imageViewer img{ max-width: 95vw; max-height: 90vh; object-fit: contain; }
    /* Avatar upload button */
    .avatar-upload{
      position:relative;
      cursor:pointer;
    }
    .avatar-upload input[type="file"]{
      position:absolute;
      inset:0;
      opacity:0;
      cursor:pointer;
      z-index:10;
    }
    .avatar-upload-overlay{
      position:absolute;
      inset:0;
      background:rgba(0,0,0,.5);
      border-radius:50%;
      display:flex;
      align-items:center;
      justify-content:center;
      opacity:0;
      transition: opacity .2s;
      pointer-events:none;
    }
    .avatar-upload:hover .avatar-upload-overlay{ opacity:1; }
    /* Chat avatar with image support */
    .chat-avatar{
      width:48px;
      height:48px;
      border-radius:50%;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:bold;
      font-size:18px;
      overflow:hidden;
      flex-shrink:0;
    }
    .chat-avatar img{
      width:100%;
      height:100%;
      object-fit:cover;
    }
    .chat-avatar-sm{
      width:40px;
      height:40px;
      font-size:16px;
    }
    .chat-avatar-lg{
      width:80px;
      height:80px;
      font-size:28px;
    }
    @media (max-width: 768px){
      .chat-avatar{ width: 44px; height: 44px; font-size: 16px; }
      .chat-avatar-lg{ width: 64px; height: 64px; font-size: 24px; }
    }
    /* Small helpers */
    .fade-in{ animation: fade .18s ease; }
    @keyframes fade{ from{ opacity:0; transform: translateY(8px);} to{ opacity:1; transform: translateY(0);} }
    .truncate-2{ display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
    /* Запрет выделения текста */
    body, .bubble, .msg-text, #chatList, #messagesContainer {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    /* Разрешаем выделение в полях ввода */
    input, textarea {
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
      user-select: text;
    }
    /* Confirm Modal */
    #confirmModal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 100;
      background: rgba(0,0,0,.7);
      backdrop-filter: blur(6px);
      padding: 16px;
    }
    #confirmModal.show { display: flex; }
    .confirm-box {
      width: 100%;
      max-width: 320px;
      border-radius: 20px;
      background: rgba(15,23,42,.98);
      border: 1px solid rgba(148,163,184,.18);
      box-shadow: 0 20px 60px rgba(0,0,0,.5);
      overflow: hidden;
      animation: fade .2s ease;
    }
    .confirm-box .confirm-header {
      padding: 20px 20px 12px;
      text-align: center;
    }
    .confirm-box .confirm-icon {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      background: rgba(239,68,68,.15);
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto 12px;
    }
    .confirm-box .confirm-icon svg {
      width: 28px;
      height: 28px;
      color: #f87171;
    }
    .confirm-box .confirm-title {
      font-size: 17px;
      font-weight: 600;
      margin-bottom: 6px;
    }
    .confirm-box .confirm-text {
      font-size: 14px;
      color: #9ca3af;
      line-height: 1.4;
    }
    .confirm-box .confirm-buttons {
      display: flex;
      border-top: 1px solid rgba(148,163,184,.15);
    }
    .confirm-box .confirm-btn {
      flex: 1;
      padding: 14px;
      border: none;
      background: transparent;
      font-size: 15px;
      font-weight: 500;
      cursor: pointer;
      transition: background .15s;
    }
    .confirm-box .confirm-btn:first-child {
      color: #9ca3af;
      border-right: 1px solid rgba(148,163,184,.15);
    }
    .confirm-box .confirm-btn:first-child:hover {
      background: rgba(148,163,184,.1);
    }
    .confirm-box .confirm-btn.danger {
      color: #f87171;
    }
    .confirm-box .confirm-btn.danger:hover {
      background: rgba(239,68,68,.15);
    }
    /* Theme button active state */
    .theme-btn.active {
      border-color: rgba(139,92,246,.9) !important;
      background: rgba(139,92,246,.1);
    }
    /* Light theme */
    body.light-theme {
      --bg: #f0f4f8;
      --panel: #ffffff;
      --panel2: #fafbfd;
      --card: rgba(255,255,255,.98);
      --border: rgba(100,116,139,.15);
      --muted: #6b7280;
      --text: #1e293b;
      --text-secondary: #475569;
      --purple: #7c3aed;
      --purple-light: #a78bfa;
      --blue: #3b82f6;
      background: var(--bg);
      color: var(--text);
    }
    body.light-theme #sidebar {
      background: var(--panel);
      border-color: var(--border);
      box-shadow: 2px 0 16px rgba(15,23,42,.04);
    }
    body.light-theme #chatArea {
      background: #fafbfd;
      border-color: var(--border);
    }
    body.light-theme .chat-header {
      background: rgba(255,255,255,.98);
      border-bottom: 1px solid rgba(100,116,139,.1);
      box-shadow: 0 1px 3px rgba(15,23,42,.03);
      backdrop-filter: blur(12px);
    }
    body.light-theme #messageInputArea {
      background: rgba(255,255,255,.98);
      border-top: 1px solid rgba(100,116,139,.1);
      box-shadow: 0 -1px 3px rgba(15,23,42,.02);
    }
    body.light-theme .bubble.in {
      background: #ffffff;
      border: 1px solid rgba(148,163,184,.1);
      color: #1e293b;
      box-shadow: 0 1px 3px rgba(15,23,42,.04), 0 1px 2px rgba(15,23,42,.02);
    }
    body.light-theme .bubble.out {
      background: linear-gradient(135deg, #7c3aed 0%, #6d28d9 100%);
      color: white;
      box-shadow: 0 2px 8px rgba(124,58,237,.2), 0 1px 3px rgba(124,58,237,.15);
      border: none;
    }
    body.light-theme .bubble.in .meta .time,
    body.light-theme .bubble.in .meta svg {
      color: #94a3b8;
    }
    body.light-theme .bubble.out .meta .time,
    body.light-theme .bubble.out .meta svg {
      color: rgba(255,255,255,.9);
    }
    body.light-theme #messageInput {
      background: #f8fafc;
      color: #1e293b;
      border: 1px solid rgba(148,163,184,.18);
    }
    body.light-theme #messageInput:focus {
      background: white;
      border-color: #7c3aed;
      box-shadow: 0 0 0 3px rgba(124,58,237,.08);
    }
    body.light-theme .icon-btn {
      background: #f8fafc;
      color: #6b7280;
      border-color: rgba(148,163,184,.12);
    }
    body.light-theme .icon-btn:hover {
      background: #f3f0ff;
      color: #7c3aed;
      border-color: rgba(124,58,237,.25);
    }
    body.light-theme .send-btn {
      background: linear-gradient(135deg, #7c3aed 0%, #6d28d9 100%);
      color: white;
      box-shadow: 0 4px 14px rgba(124,58,237,.25);
    }
    body.light-theme .send-btn:hover {
      box-shadow: 0 6px 20px rgba(124,58,237,.35);
      transform: translateY(-1px);
    }
    body.light-theme .sheet,
    body.light-theme .modal > div {
      background: white;
      border: 1px solid rgba(148,163,184,.1);
      box-shadow: 0 20px 60px rgba(15,23,42,.08), 0 8px 16px rgba(15,23,42,.04);
    }
    body.light-theme .glass {
      background: rgba(255,255,255,.96);
      backdrop-filter: blur(16px);
    }
    body.light-theme input,
    body.light-theme textarea,
    body.light-theme select {
      background: #f8fafc;
      color: #1e293b;
      border: 1px solid rgba(148,163,184,.18);
    }
    body.light-theme input:focus,
    body.light-theme textarea:focus,
    body.light-theme select:focus {
      background: white;
      border-color: #7c3aed;
      box-shadow: 0 0 0 3px rgba(124,58,237,.08);
    }
    body.light-theme .voice-message {
      background: white;
      border: 1px solid rgba(148,163,184,.1);
      box-shadow: 0 1px 3px rgba(15,23,42,.04);
    }
    body.light-theme .voice-bar {
      background: rgba(124,58,237,.18);
    }
    body.light-theme .voice-bar.active {
      background: #7c3aed;
    }
    body.light-theme .voice-duration {
      color: #6b7280;
    }
    body.light-theme .chat-avatar {
      box-shadow: 0 2px 8px rgba(15,23,42,.06);
    }
    body.light-theme #chatList > div {
      border-bottom: 1px solid rgba(148,163,184,.06);
    }
    body.light-theme #chatList > div:hover {
      background: #fafbfd;
    }
    body.light-theme #emptyChat {
      color: #6b7280;
    }
    body.light-theme .context-menu-btn {
      color: #1e293b;
    }
    body.light-theme .context-menu-btn:hover {
      background: #f8fafc;
    }
    body.light-theme .context-menu-btn.text-red-400 {
      color: #dc2626;
    }
    body.light-theme .context-menu-btn.text-red-400:hover {
      background: rgba(220,38,38,.06);
    }
    body.light-theme #messageContextMenu {
      background: white;
      border: 1px solid rgba(148,163,184,.1);
      box-shadow: 0 8px 24px rgba(15,23,42,.08), 0 2px 8px rgba(15,23,42,.04);
    }
    body.light-theme .context-menu-divider {
      background: rgba(148,163,184,.1);
    }
    body.light-theme .emoji-picker {
      background: white;
      border: 1px solid rgba(148,163,184,.1);
      box-shadow: 0 8px 24px rgba(15,23,42,.08), 0 2px 8px rgba(15,23,42,.04);
    }
    body.light-theme .emoji-tab {
      background: #f8fafc;
      color: #6b7280;
    }
    body.light-theme .emoji-tab.active {
      background: white;
      color: #7c3aed;
      border-bottom-color: #7c3aed;
    }
    body.light-theme .emoji-btn {
      background: #fafbfd;
      border-color: rgba(148,163,184,.1);
    }
    body.light-theme .emoji-btn:hover {
      background: #f3f0ff;
      border-color: #a78bfa;
      transform: scale(1.1);
    }
    body.light-theme .file-chip {
      background: white;
      border: 1px solid rgba(148,163,184,.1);
      box-shadow: 0 1px 3px rgba(15,23,42,.04);
    }
    body.light-theme #messagesContainer {
      background: #fafbfd;
    }
    body.light-theme #pinnedMessage {
      background: rgba(124,58,237,.05);
      border-bottom: 1px solid rgba(124,58,237,.12);
    }
    body.light-theme .scrollbar::-webkit-scrollbar-track {
      background: #f8fafc;
    }
    body.light-theme .scrollbar::-webkit-scrollbar-thumb {
      background: #cbd5e1;
      border-radius: 4px;
    }
    body.light-theme .scrollbar::-webkit-scrollbar-thumb:hover {
      background: #94a3b8;
    }
    body.light-theme .confirm-box {
      background: white;
      border: 1px solid rgba(148,163,184,.1);
      box-shadow: 0 20px 60px rgba(15,23,42,.12), 0 8px 16px rgba(15,23,42,.06);
    }
    body.light-theme .confirm-box .confirm-text {
      color: #6b7280;
    }
    body.light-theme .confirm-box .confirm-buttons {
      border-top: 1px solid rgba(148,163,184,.1);
    }
    body.light-theme .confirm-box .confirm-btn:first-child {
      color: #6b7280;
      border-right: 1px solid rgba(148,163,184,.1);
    }
    body.light-theme .confirm-box .confirm-btn:first-child:hover {
      background: #f8fafc;
    }
    body.light-theme .confirm-box .confirm-btn.danger {
      color: #dc2626;
    }
    body.light-theme .confirm-box .confirm-btn.danger:hover {
      background: rgba(220,38,38,.06);
    }
    body.light-theme .reaction-btn:hover {
      background: #f8fafc;
    }
    body.light-theme .edited-indicator {
      color: #94a3b8;
    }
    body.light-theme #imageViewer {
      background: rgba(255,255,255,.98);
    }
    body.light-theme .avatar-upload-overlay {
      background: rgba(0,0,0,.35);
    }
    body.light-theme .theme-btn {
      background: #f8fafc;
      border-color: rgba(148,163,184,.18);
      color: #1e293b;
    }
    body.light-theme .theme-btn:hover {
      background: #f3f0ff;
      border-color: rgba(124,58,237,.25);
    }
    body.light-theme .theme-btn.active {
      border-color: #7c3aed !important;
      background: rgba(124,58,237,.08);
      color: #7c3aed;
    }
    body.light-theme #uploadPreview {
      background: rgba(255,255,255,.98);
      border-top: 1px solid rgba(100,116,139,.1);
    }
    body.light-theme #typingIndicator {
      color: #6b7280;
    }
    body.light-theme .dev-badge {
      background: rgba(124,58,237,.08);
      color: #7c3aed;
      border-color: rgba(124,58,237,.18);
    }
    body.light-theme #authScreen {
      background: linear-gradient(135deg, #ddd6fe 0%, #e9d5ff 50%, #fae8ff 100%);
    }
    body.light-theme .modal {
      background: rgba(15,23,42,.35);
      backdrop-filter: blur(4px);
    }
    body.light-theme button:not(.icon-btn):not(.send-btn):not(.confirm-btn):not(.context-menu-btn):not(.emoji-btn):not(.reaction-btn):not(.theme-btn) {
      background: #7c3aed;
      color: white;
      border: none;
      box-shadow: 0 2px 8px rgba(124,58,237,.2);
    }
    body.light-theme button:not(.icon-btn):not(.send-btn):not(.confirm-btn):not(.context-menu-btn):not(.emoji-btn):not(.reaction-btn):not(.theme-btn):hover {
      background: #6d28d9;
      box-shadow: 0 4px 12px rgba(124,58,237,.3);
    }
    body.light-theme .scrollbar::-webkit-scrollbar-thumb:hover {
      background: #94a3b8;
    }
    /* Toast для копирования */
    .copy-toast {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(15,23,42,.95);
      border: 1px solid rgba(148,163,184,.2);
      border-radius: 12px;
      padding: 10px 20px;
      font-size: 14px;
      color: #e5e7eb;
      z-index: 200;
      animation: fadeInUp .2s ease;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    @keyframes fadeInUp {
      from { opacity: 0; transform: translate(-50%, 10px); }
      to { opacity: 1; transform: translate(-50%, 0); }
    }
    /* Reply preview / quote */
    #replyPreview{ display:none; }
    #replyPreview.show{ display:block; }
    .reply-quote{
      border-left: 3px solid rgba(139,92,246,.9);
      background: rgba(139,92,246,.10);
      padding: 8px 10px;
      border-radius: 12px;
      margin-bottom: 8px;
      cursor:pointer;
    }
    .reply-quote .ra{ font-size:12px; color: rgba(167,139,250,.95); font-weight:600; }
    .reply-quote .rt{ font-size:12px; color: rgba(226,232,240,.85); margin-top:2px; }

    .reply-quote{
      display:block;
      max-width:100%;
      padding:6px 10px;
      margin-bottom:6px;
      line-height:1.2;
    }
    .reply-quote .ra{line-height:1.2}
    .reply-quote .rt{line-height:1.2;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    /* Swipe-to-reply animation */
    .bubble{ transition: transform .12s ease; will-change: transform; }
    .swipe-reply-icon{
      position:absolute;
      right: 10px;
      left: auto;
      top: 50%;
      transform: translateY(-50%) scale(.9);
      width:34px; height:34px;
      border-radius:999px;
      background: rgba(139,92,246,.22);
      border: 1px solid rgba(139,92,246,.35);
      display:flex;
      align-items:center;
      justify-content:center;
      opacity:0;
      pointer-events:none;
      transition: opacity .12s ease, transform .12s ease;
    }
    .swipe-reply-icon.show{
      opacity:1;
      transform: translateY(-50%) scale(1);
    }
    .swipe-reply-icon svg{ width:18px; height:18px; color: rgba(167,139,250, .98); }
    /* Forwarded badge */
    .fwd-badge{
      margin-bottom:6px;
      padding:6px 10px;
      border-radius:12px;
      background: rgba(2,6,23,.25);
      border:1px solid rgba(148,163,184,.12);
      font-size:12px;
      color: rgba(148,163,184,.95);
      display:flex;
      align-items:center;
      gap:8px;
      cursor:default;
      user-select:none;
    }
    .bubble.out .fwd-badge{
      background: rgba(255,255,255,.10);
      border-color: rgba(255,255,255,.18);
      color: rgba(255,255,255,.9);
    }
    .fwd-badge .fwd-name{ font-weight:600; color: rgba(167,139,250,.95); }
    .bubble.out .fwd-badge .fwd-name{ color: rgba(255,255,255,.95); }
    .msg-highlight{ animation: msgflash 1.2s ease; }
    @keyframes msgflash{
      0%{ box-shadow: 0 0 0 0 rgba(139,92,246,.0); }
      30%{ box-shadow: 0 0 0 4px rgba(139,92,246,.22); }
      100%{ box-shadow: 0 0 0 0 rgba(139,92,246,.0); }
    }
    /* Message menu button (TG-like) */
    .bubble-wrap{
      display:flex;
      align-items:center;
      gap:10px;
      max-width:100%;
      position:relative;
    }
    /* incoming: bubble then button on the right */
    .bubble-wrap.in{ justify-content:flex-start; flex-direction:row; }
    /* outgoing: button on the left then bubble */
    .bubble-wrap.out{ justify-content:flex-end; flex-direction:row; }
    .msg-menu-btn{
      width:30px;
      height:30px;
      border-radius:999px;
      display:grid;
      place-items:center;
      border:1px solid rgba(148,163,184,.22);
      background:rgba(15,23,42,.62);
      color:#e5e7eb;
      cursor:pointer;
      flex:0 0 auto;
      transition: all .15s ease;
      box-shadow: 0 8px 22px rgba(0,0,0,.25);
      touch-action: manipulation;
      position:relative;
      z-index:6;
      pointer-events:auto;
    }
    /* msg-menu-btn mobile */
    @media (max-width: 768px){
      .msg-menu-btn{ width:36px; height:36px; }
    }
.msg-menu-btn svg{ width:20px; height:20px; }
    .msg-menu-btn:active{ transform: scale(.96); }
    .msg-menu-btn:hover{ background:rgba(31,41,55,.55); color:white; }
    @media (max-width: 768px){
      .msg-menu-btn{ width:36px; height:36px; }
      .msg-menu-btn svg{ width:20px; height:20px; }
      .bubble-wrap{ gap:12px; }
    }
    /* ===== AUTH VISIBILITY BOOST ===== */
    #authScreen .glass{
      background: rgba(2,6,23,.65) !important;
      border-color: rgba(167,139,250,.45) !important;
      box-shadow: 0 18px 50px rgba(0,0,0,.35) !important;
      backdrop-filter: blur(18px) saturate(140%);
    }
    #authScreen h1{ color: rgba(255,255,255,.98) !important; text-shadow: 0 2px 14px rgba(0,0,0,.35); }
    #authScreen p{ color: rgba(226,232,240,.78) !important; }
    #authScreen input, #authScreen textarea{
      background: rgba(255,255,255,.08) !important;
      border: 1px solid rgba(167,139,250,.35) !important;
      color: rgba(255,255,255,.95) !important;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.04);
    }
    #authScreen input::placeholder, #authScreen textarea::placeholder{
      color: rgba(226,232,240,.55) !important;
    }
    #authScreen input:focus, #authScreen textarea:focus{
      outline: none !important;
      border-color: rgba(167,139,250,.75) !important;
      box-shadow: 0 0 0 4px rgba(167,139,250,.15) !important;
    }
    #authScreen button#loginTab, #authScreen button#registerTab{
      font-weight: 700;
      letter-spacing: .2px;
    }
    #authScreen .gradient-bg{
      box-shadow: 0 18px 40px rgba(124,58,237,.35) !important;
    }
/* ==== UI polish: sidebar (main menu) ==== */
#sidebar{
  background: rgba(15,23,42,.55);
  backdrop-filter: blur(18px);
  -webkit-backdrop-filter: blur(18px);
  border-right: 1px solid rgba(148,163,184,.14);
}
#sidebar .p-3.border-b{
  position: sticky;
  top: 0;
  z-index: 5;
  background: linear-gradient(180deg, rgba(15,23,42,.88) 0%, rgba(15,23,42,.55) 100%);
  backdrop-filter: blur(18px);
  -webkit-backdrop-filter: blur(18px);
}
#sidebar h2{
  letter-spacing: .2px;
}
#sidebar .icon-btn{
  border-color: rgba(148,163,184,.22) !important;
  background: rgba(2,6,23,.25) !important;
}
#sidebar .icon-btn:hover{
  background: rgba(2,6,23,.38) !important;
}
#chatList .chat-item{
  border: 1px solid rgba(148,163,184,.12);
  background: rgba(2,6,23,.18);
  transition: transform .12s ease, background .12s ease, border-color .12s ease;
}
#chatList .chat-item:hover{
  background: rgba(2,6,23,.28);
  border-color: rgba(167,139,250,.28);
  transform: translateY(-1px);
}
/* ==== UI polish: saved accounts “striped” rows ==== */
#savedAccounts .saved-acc-row{
  position: relative;
  overflow: hidden;
  border-radius: 16px;
  border: 1px solid rgba(148,163,184,.14);
  background: rgba(2,6,23,.22);
}
#savedAccounts .saved-acc-row::before{
  content:"";
  position:absolute;
  left:0; top:0; bottom:0;
  width: 4px;
  background: linear-gradient(180deg, rgba(167,139,250,.95), rgba(99,102,241,.75));
}
#savedAccounts .saved-acc-row:hover{
  border-color: rgba(167,139,250,.28);
  background: rgba(2,6,23,.28);
}
#savedAccounts .saved-acc-avatar{
  background: linear-gradient(135deg, rgba(167,139,250,.95), rgba(99,102,241,.85));
  box-shadow: 0 10px 22px rgba(99,102,241,.18);
}
#savedAccounts .saved-acc-login{
  background: linear-gradient(135deg, rgba(139,92,246,.95), rgba(99,102,241,.85));
  box-shadow: 0 10px 22px rgba(99,102,241,.18);
}
#savedAccounts .saved-acc-login:hover{
  filter: brightness(1.05);
}
/* ===== Global "polished" UI for ALL windows/panels/modals ===== */
:where(.card, .glass, .panel, .panel2){ border:1px solid var(--border); }
:where(button, .icon-btn, .send-btn, .msg-menu-btn){ transition: transform .12s ease, opacity .12s ease, background .12s ease, border-color .12s ease; }
:where(button, .icon-btn, .send-btn, .msg-menu-btn):active{ transform: scale(.98); }
:where(input, textarea, select){
  background: rgba(2,6,23,.35);
  border: 1px solid rgba(148,163,184,.18);
  color: var(--text);
  border-radius: 14px;
  outline: none;
}
:where(input, textarea, select)::placeholder{ color: rgba(148,163,184,.75); }
:where(input, textarea, select):focus{
  border-color: rgba(139,92,246,.55);
  box-shadow: 0 0 0 4px rgba(139,92,246,.15);
}
/* Sidebar + headers */
#sidebar, #chatArea{ background: rgba(15,23,42,.55); backdrop-filter: blur(14px); }
#sidebar{ border-right: 1px solid rgba(148,163,184,.14); }
#chatArea{ border-left: 1px solid rgba(148,163,184,.06); }
#sidebar .sticky, #chatArea .sticky{ backdrop-filter: blur(14px); }
/* Saved accounts "stripes" everywhere it appears */
#savedAccountsContainer, #savedAccountsList{ }
#savedAccountsList > div{ position:relative; overflow:hidden; }
#savedAccountsList > div::before{
  content:"";
  position:absolute;
  left:0; top:0; bottom:0;
  width:4px;
  background: linear-gradient(180deg, rgba(139,92,246,.9), rgba(96,165,250,.8));
  opacity:.9;
}
/* ===== Modals: make ALL modal windows consistent ===== */
.modal{ background: rgba(2,6,23,.72); backdrop-filter: blur(10px); }
.modal > div{
  background: rgba(15,23,42,.78) !important;
  border: 1px solid rgba(148,163,184,.18) !important;
  border-radius: 22px !important;
  box-shadow: 0 22px 60px rgba(0,0,0,.55) !important;
  max-width: min(560px, 96vw);
}
.modal h1,.modal h2,.modal h3{ color: rgba(255,255,255,.95) !important; letter-spacing:.2px; }
.modal .text-slate-400{ color: rgba(148,163,184,.9) !important; }
.modal button{
  border-radius: 14px;
}
.modal button.bg-violet-600, .modal button.bg-violet-500, .modal button.gradient-bg{
  box-shadow: 0 10px 24px rgba(139,92,246,.25);
}
.modal button:hover{ filter: brightness(1.03); }
.modal .icon-btn{
  background: rgba(255,255,255,.06);
  border: 1px solid rgba(148,163,184,.16);
}
.modal .icon-btn:hover{ background: rgba(255,255,255,.10); }
/* ===== Context menu / message actions ===== */
#messageContextMenu{
  background: rgba(15,23,42,.92);
  border: 1px solid rgba(148,163,184,.18);
  box-shadow: 0 20px 60px rgba(0,0,0,.55);
  backdrop-filter: blur(14px);
  border-radius: 18px;
}
#messageContextMenu button{
  border-radius: 14px;
}
#messageContextMenu button:hover{ background: rgba(255,255,255,.08); }
/* ===== Bottom sheet (mobile menus) ===== */
.bottom-sheet, .sheet{
  background: rgba(15,23,42,.92);
  border: 1px solid rgba(148,163,184,.18);
  box-shadow: 0 -18px 60px rgba(0,0,0,.55);
  backdrop-filter: blur(18px);
  border-top-left-radius: 22px;
  border-top-right-radius: 22px;
}
/* ===== Reply quote inside sent messages ===== */
.reply-quote, .replyQuote{
  background: rgba(255,255,255,.08);
  border: 1px solid rgba(148,163,184,.16);
  border-radius: 14px;
  box-shadow: inset 0 0 0 1px rgba(255,255,255,.03);
}
.reply-quote::before, .replyQuote::before{
  content:"";
  position:absolute;
  left:10px; top:10px; bottom:10px;
  width:3px;
  border-radius:999px;
  background: linear-gradient(180deg, rgba(139,92,246,.95), rgba(96,165,250,.85));
}
/* ===== Toasts ===== */
#toastContainer > div{
  background: rgba(15,23,42,.92) !important;
  border: 1px solid rgba(148,163,184,.18) !important;
  box-shadow: 0 18px 60px rgba(0,0,0,.55) !important;
  backdrop-filter: blur(14px);
  border-radius: 18px !important;
}
/* Responsive spacing tweaks */
@media (max-width: 768px){
  .modal{ padding: 10px; }
  .modal > div{ max-width: 96vw; }
}


.circle-rec-iconbtn.active{background:rgba(250,204,21,.18)!important;border-color:rgba(250,204,21,.35)!important}
/* TG-like circle & voice recording overlays */
#tgCircleOverlay,#tgVoiceOverlay{position:fixed;inset:0;z-index:9999;display:none}
#tgCircleOverlay.show,#tgVoiceOverlay.show{display:block}
#tgCircleOverlay{background:rgba(2,6,23,.72);backdrop-filter:blur(10px)}
#tgCircleWrap{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;padding:16px}
#tgCircleVideo{width:min(78vw,78vh);height:min(78vw,78vh);border-radius:9999px;object-fit:cover;box-shadow:0 30px 80px rgba(0,0,0,.55);border:1px solid rgba(255,255,255,.08)}
#tgCircleArc{position:absolute;top:calc(50% - min(78vw,78vh)/2 - 18px);left:50%;transform:translateX(-50%);width:44px;height:12px;border-radius:999px;background:rgba(255,255,255,.9);filter:drop-shadow(0 6px 18px rgba(0,0,0,.35));opacity:.9}
#tgCircleBottom{position:absolute;left:0;right:0;bottom:0;padding:14px 16px calc(18px + env(safe-area-inset-bottom));display:flex;align-items:center;gap:12px;justify-content:center}
#tgCircleHint{flex:1;max-width:360px;text-align:center;color:rgba(255,255,255,.85);font-weight:600;letter-spacing:.2px}
#tgCircleTime{color:rgba(255,255,255,.9);font-weight:700;min-width:72px;text-align:left}
#tgCircleDot{width:10px;height:10px;border-radius:999px;background:rgba(239,68,68,.95);box-shadow:0 0 0 6px rgba(239,68,68,.16);animation:tgPulse 1.2s ease-in-out infinite}
@keyframes tgPulse{0%,100%{transform:scale(1)}50%{transform:scale(1.25)}}
.tgCircleBtn{width:clamp(44px,12vw,64px);height:clamp(44px,12vw,64px);border-radius:999px;border:1px solid rgba(255,255,255,.12);background:rgba(2,6,23,.35);backdrop-filter:blur(10px);display:flex;align-items:center;justify-content:center;box-shadow:0 18px 40px rgba(0,0,0,.35);color:#fff}
.tgCircleBtn:active{transform:scale(.98)}
#tgCircleRec{position:absolute;right:16px;bottom:calc(18px + env(safe-area-inset-bottom) + 18px);width:clamp(68px,18vw,92px);height:clamp(68px,18vw,92px);border-radius:999px;background:rgba(99,102,241,.22);border:1px solid rgba(167,139,250,.28);display:flex;align-items:center;justify-content:center;box-shadow:0 30px 90px rgba(0,0,0,.55)}
#tgCircleRecInner{width:clamp(54px,14vw,74px);height:clamp(54px,14vw,74px);border-radius:999px;background:rgba(255,255,255,.92);display:flex;align-items:center;justify-content:center}
#tgCircleRecInner::after{content:"";width:clamp(16px,4vw,20px);height:clamp(16px,4vw,20px);border-radius:6px;background:rgba(99,102,241,.95)}
/* Voice overlay like TG */
#tgVoiceOverlay{pointer-events:none}
#tgVoiceBar{position:absolute;left:12px;right:12px;bottom:calc(12px + env(safe-area-inset-bottom) + 78px);margin:0 auto;max-width:520px;pointer-events:auto;background:rgba(2,6,23,.55);backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,.12);border-radius:18px;box-shadow:0 25px 70px rgba(0,0,0,.45);padding:12px 14px;display:flex;align-items:center;gap:12px}
#tgVoiceArc{width:44px;height:12px;border-radius:999px;background:rgba(255,255,255,.9);opacity:.9}
#tgVoiceDot{width:10px;height:10px;border-radius:999px;background:rgba(239,68,68,.95);box-shadow:0 0 0 6px rgba(239,68,68,.16);animation:tgPulse 1.2s ease-in-out infinite}
#tgVoiceTime{color:rgba(255,255,255,.92);font-weight:800;min-width:66px}
#tgVoiceHint{flex:1;color:rgba(255,255,255,.85);font-weight:700;text-align:center}
#tgVoiceCancel{color:rgba(255,255,255,.92);font-weight:800;padding:8px 10px;border-radius:14px;border:1px solid rgba(255,255,255,.12);background:rgba(2,6,23,.25)}
#tgVoiceWave{display:flex;align-items:center;gap:3px}
#tgVoiceWave i{display:block;width:3px;height:16px;border-radius:999px;background:rgba(255,255,255,.7);animation:tgWave 1s ease-in-out infinite}
#tgVoiceWave i:nth-child(2){animation-delay:.08s}
#tgVoiceWave i:nth-child(3){animation-delay:.16s}
#tgVoiceWave i:nth-child(4){animation-delay:.24s}
#tgVoiceWave i:nth-child(5){animation-delay:.32s}
@keyframes tgWave{0%,100%{transform:scaleY(.55);opacity:.6}50%{transform:scaleY(1.35);opacity:1}}
@media (max-width:380px){
  #tgCircleHint{display:none}
  #tgVoiceHint{display:none}
}


.bubble.has-circle{padding:0!important;background:transparent!important;box-shadow:none!important;border:none!important}
.bubble.has-circle .meta{position:absolute;right:10px;bottom:10px;background:rgba(0,0,0,.35);backdrop-filter:blur(6px);border-radius:10px;padding:4px 8px;display:flex;gap:6px;align-items:center}
.bubble.has-circle .meta .time{color:rgba(255,255,255,.92)}
.bubble.has-circle .reactions{margin:6px 0 0 0}
.bubble.has-circle .sender-line{margin-left:8px}
/* ====== LIVE CIRCLE RECORDING PREVIEW (TG-like) ====== */
#circlePreviewOverlay{
  position: fixed;
  inset: 0;
  background: rgba(2,6,23,.72);
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
  display:none;
  align-items:center;
  justify-content:center;
  z-index: 10050;
  padding: 16px;
}
#circlePreviewOverlay.show{ display:flex; }

.circle-preview-card{
  width: min(360px, 100%);
  display:flex;
  flex-direction:column;
  align-items:center;
  gap: 14px;
}

.circle-preview-video-wrap{
  width: min(320px, 82vw);
  aspect-ratio: 1/1;
  border-radius: 9999px;
  overflow:hidden;
  position: relative;
  border: 2px solid rgba(139,92,246,.55);
  box-shadow: 0 18px 50px rgba(0,0,0,.45);
  background: rgba(0,0,0,.35);
}

#circlePreviewVideo{
  width:100%;
  height:100%;
  object-fit: cover;
  transform: scaleX(-1); /* selfie-like */
}

.circle-preview-hud{
  position:absolute;
  inset: 0;
  pointer-events:none;
  display:flex;
  align-items:flex-end;
  justify-content:center;
  padding: 14px;
}

.circle-preview-pill{
  pointer-events:none;
  padding: 6px 10px;
  border-radius: 999px;
  font-size: 12px;
  color: rgba(255,255,255,.92);
  background: rgba(2,6,23,.45);
  border: 1px solid rgba(148,163,184,.22);
}

.circle-preview-actions{
  width:100%;
  display:flex;
  gap: 10px;
  justify-content:center;
}

.circle-preview-actions .btn{
  flex:1 1 auto;
  max-width: 180px;
}
.circle-preview-actions .btn-danger{
  background: rgba(239,68,68,.92);
}
.circle-preview-actions .btn-ghost{
  background: rgba(15,23,42,.40);
  border: 1px solid rgba(148,163,184,.18);
}


/* ===== TG-like Circle Recorder Overlay (video message) ===== */
.circle-rec-overlay{
  position: fixed;
  inset: 0;
  z-index: 10060;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  background: rgba(2,6,23,.55);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  touch-action: none;
}
.circle-rec-overlay.hidden{ display:none; }

.circle-rec-bg{
  position:absolute;
  inset:0;
  width:100%;
  height:100%;
  object-fit: cover;
  filter: blur(18px) brightness(.55);
  transform: scale(1.06);
  opacity: .65;
}

.circle-rec-top{
  position: relative;
  z-index: 1;
  padding: 14px 14px 0 14px;
  display:flex;
  justify-content:flex-end;
}

.circle-rec-center{
  position: relative;
  z-index: 1;
  display:flex;
  justify-content:center;
  align-items:center;
  padding: 12px 0;
  --circleSize: min(82vw, 56vh, 380px);
}

.circle-rec-circle{
  width: var(--circleSize);
  height: var(--circleSize);
  border-radius: 9999px;
  overflow: hidden;
  background: rgba(0,0,0,.25);
  box-shadow: 0 24px 70px rgba(0,0,0,.55);
}
#circleRecVideo{
  width:100%;
  height:100%;
  object-fit: cover;
  transform: scaleX(-1);
}

.circle-rec-ring{
  position:absolute;
  width: calc(var(--circleSize) + 18px);
  height: calc(var(--circleSize) + 18px);
  border-radius: 9999px;
  border: 3px solid rgba(255,255,255,.12);
  box-shadow: inset 0 0 0 1px rgba(139,92,246,.25);
}
.circle-rec-ring::after{
  content:"";
  position:absolute;
  left:50%;
  top:-2px;
  width: 68px;
  height: 6px;
  transform: translateX(-50%);
  border-radius: 999px;
  background: rgba(255,255,255,.85);
  box-shadow: 0 10px 22px rgba(0,0,0,.35);
  opacity: .9;
}

.circle-rec-bottom{
  position: relative;
  z-index: 1;
  padding: 14px 14px calc(14px + env(safe-area-inset-bottom));
  display:flex;
  align-items:flex-end;
  gap: 10px;
}

.circle-rec-actions{
  display:flex;
  gap: 10px;
}

.circle-rec-hint{
  flex: 1;
  display:flex;
  align-items:center;
  gap: 10px;
  justify-content:center;
  color: rgba(255,255,255,.92);
  user-select:none;
}

.circle-rec-time{
  font-variant-numeric: tabular-nums;
  font-weight: 700;
  font-size: 18px;
  padding: 6px 10px;
  border-radius: 999px;
  background: rgba(0,0,0,.25);
  border: 1px solid rgba(255,255,255,.12);
}

.circle-rec-cancel{
  font-size: 16px;
  opacity: .9;
  padding: 6px 10px;
  border-radius: 999px;
  background: rgba(0,0,0,.18);
  border: 1px solid rgba(255,255,255,.10);
}
.circle-rec-cancel.canceling{
  background: rgba(239,68,68,.22);
  border-color: rgba(239,68,68,.35);
}

.circle-rec-recbtn-wrap{
  display:flex;
  justify-content:flex-end;
}
.circle-rec-recbtn{
  width: 74px;
  height: 74px;
  border-radius: 9999px;
  background: rgba(59,130,246,.35);
  border: 2px solid rgba(255,255,255,.18);
  display:grid;
  place-items:center;
  box-shadow: 0 18px 40px rgba(0,0,0,.45);
}
.circle-rec-recinner{
  width: 26px;
  height: 26px;
  border-radius: 10px;
  background: rgba(255,255,255,.95);
  opacity: .95;
}
.circle-rec-recbtn.recording{
  background: rgba(239,68,68,.35);
}
.circle-rec-recbtn.recording .circle-rec-recinner{
  border-radius: 6px;
  width: 22px;
  height: 22px;
}

/* Recording button pulse (Telegram-like) */
.circle-rec-recbtn{ position: relative; overflow: visible; }
.circle-rec-recbtn::before,
.circle-rec-recbtn::after{
  content:"";
  position:absolute;
  inset:-10px;
  border-radius:9999px;
  background: rgba(239,68,68,.18);
  opacity:0;
  pointer-events:none;
}
.circle-rec-recbtn.recording::before{
  opacity:1;
  animation: crPulse1 1.25s ease-in-out infinite;
}
.circle-rec-recbtn.recording::after{
  opacity:1;
  inset:-18px;
  background: rgba(239,68,68,.10);
  animation: crPulse2 1.25s ease-in-out infinite;
}
.circle-rec-recinner{ position: relative; z-index: 1; }
@keyframes crPulse1{
  0%{ transform:scale(.92); opacity:.75; }
  70%{ transform:scale(1.08); opacity:0; }
  100%{ transform:scale(1.08); opacity:0; }
}
@keyframes crPulse2{
  0%{ transform:scale(.88); opacity:.55; }
  70%{ transform:scale(1.18); opacity:0; }
  100%{ transform:scale(1.18); opacity:0; }
}

/* Pretty arc/progress indicator around the circle */
.circle-rec-progress{
  position:absolute;
  width: calc(var(--circleSize) + 26px);
  height: calc(var(--circleSize) + 26px);
  pointer-events:none;
  transform: rotate(-90deg);
  filter: drop-shadow(0 10px 26px rgba(0,0,0,.35));
}
.circle-rec-progress .crp-track{
  fill:none;
  stroke: rgba(255,255,255,.10);
  stroke-width: 3;
}
.circle-rec-progress .crp-bar{
  fill:none;
  stroke: rgba(255,255,255,.92);
  stroke-width: 4;
  stroke-linecap: round;
  stroke-dasharray: 301.59;
  stroke-dashoffset: 301.59;
  transition: stroke-dashoffset .12s linear;
}

.circle-rec-iconbtn{
  width: 46px;
  height: 46px;
  border-radius: 9999px;
  background: rgba(0,0,0,.25);
  border: 1px solid rgba(255,255,255,.12);
  color: rgba(255,255,255,.92);
  display:grid;
  place-items:center;
  font-size: 18px;
}
.circle-rec-iconbtn:active{ transform: scale(.98); }

@media (min-width: 900px){
  .circle-rec-recbtn{ width: 68px; height: 68px; }
  .circle-rec-iconbtn{ width: 42px; height: 42px; }
}



/* ===== Circle drag up to send ===== */
.circle-rec-center .circle-rec-circle,
.circle-rec-center .circle-rec-ring,
.circle-rec-center .circle-rec-progress{
  transition: transform .18s ease;
  will-change: transform;
  touch-action: none;
}
.circle-rec-center.dragging .circle-rec-circle,
.circle-rec-center.dragging .circle-rec-ring,
.circle-rec-center.dragging .circle-rec-progress{
  transition: none;
}
.circle-rec-center.send-armed .circle-rec-ring{
  box-shadow: inset 0 0 0 1px rgba(239,68,68,.22), 0 0 0 10px rgba(239,68,68,.12);
}

</style>
</head>
<body>
  <div id="appShell">
    <!-- AUTH -->
    <div id="authScreen" class="px-4 py-10">
      <div class="mx-auto w-full max-w-md">
        <div class="text-center mb-8">
          <div class="w-20 h-20 gradient-bg rounded-2xl mx-auto mb-4 flex items-center justify-center shadow-lg">
            <svg class="w-12 h-12 text-white" fill="currentColor" viewBox="0 0 24 24"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H6l-2 2V4h16v12z"/></svg>
          </div>
          <h1 class="text-3xl font-bold">FlashChat Pro</h1>
          <p class="text-slate-400 mt-2">Мессенджер нового поколения</p>
        </div>
        <div id="savedAccounts" class="hidden mb-4">
          <p class="text-sm text-slate-400 mb-2">Сохранённые аккаунты:</p>
          <div id="accountsList" class="space-y-2 max-h-40 overflow-auto scrollbar"></div>
        </div>
        <div class="glass rounded-3xl p-6 border" style="border-color: var(--border)">
          <div class="flex mb-6 bg-white/5 rounded-xl p-1">
            <button id="loginTab" class="flex-1 py-2 px-4 rounded-lg font-medium transition-all bg-violet-600 text-white" onclick="showTab('login')">Вход</button>
            <button id="registerTab" class="flex-1 py-2 px-4 rounded-lg font-medium transition-all text-slate-400" onclick="showTab('register')">Регистрация</button>
          </div>
          <form id="loginForm" class="space-y-4" onsubmit="login(event)">
            <input type="email" id="loginEmail" required placeholder="Email" class="w-full bg-white/5 border border-white/10 rounded-xl px-4 py-3 outline-none focus:border-violet-500">
            <input type="password" id="loginPassword" required placeholder="Пароль" class="w-full bg-white/5 border border-white/10 rounded-xl px-4 py-3 outline-none focus:border-violet-500">
            <label class="flex items-center gap-2 text-sm text-slate-400">
              <input type="checkbox" id="saveAccount" checked>
              <span>Запомнить аккаунт</span>
            </label>
            <button type="submit" class="w-full gradient-bg py-3 rounded-xl font-semibold hover:opacity-95">Войти</button>
          </form>
          <form id="registerForm" class="space-y-4 hidden" onsubmit="register(event)">
            <input type="text" id="registerName" required placeholder="Имя пользователя" class="w-full bg-white/5 border border-white/10 rounded-xl px-4 py-3 outline-none focus:border-violet-500">
            <input type="email" id="registerEmail" required placeholder="Email" class="w-full bg-white/5 border border-white/10 rounded-xl px-4 py-3 outline-none focus:border-violet-500">
            <input type="password" id="registerPassword" required minlength="6" placeholder="Пароль (мин. 6 символов)" class="w-full bg-white/5 border border-white/10 rounded-xl px-4 py-3 outline-none focus:border-violet-500">
            <button type="submit" class="w-full gradient-bg py-3 rounded-xl font-semibold hover:opacity-95">Создать аккаунт</button>
          </form>
          <div id="authError" class="mt-4 text-red-300 text-sm text-center hidden"></div>
        </div>
      </div>
    </div>
    <!-- CHAT -->
    <div id="chatScreen">
      <!-- Sidebar -->
      <aside id="sidebar" class="safe-top">
        <div class="p-3 border-b" style="border-color: var(--border)">
          <div class="flex items-center justify-between mb-3">
            <h2 class="text-xl font-bold">FlashChat</h2>
            <div class="flex gap-1">
              <button class="icon-btn" title="Создать" onclick="showCreateMenu()">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/></svg>
              </button>
              <button class="icon-btn" title="Аккаунты" onclick="showAccountSwitcher()">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0z"/></svg>
              </button>
              <button class="icon-btn" title="Настройки" onclick="showAppSettings()">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"/><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/></svg>
              </button>
              <button class="icon-btn" title="Профиль" onclick="showProfile()">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"/></svg>
              </button>
            </div>
          </div>
          <div class="flex gap-1 mb-3 bg-white/5 rounded-xl p-1">
            <button id="tabAll" class="flex-1 py-2 px-3 rounded-lg text-sm font-medium bg-violet-600" onclick="showChatTab('all')">Все</button>
            <button id="tabPrivate" class="flex-1 py-2 px-3 rounded-lg text-sm font-medium text-slate-400" onclick="showChatTab('private')">Личные</button>
            <button id="tabGroups" class="flex-1 py-2 px-3 rounded-lg text-sm font-medium text-slate-400" onclick="showChatTab('groups')">Группы</button>
            <button id="tabChannels" class="flex-1 py-2 px-3 rounded-lg text-sm font-medium text-slate-400" onclick="showChatTab('channels')">Каналы</button>
          </div>
          <div class="relative">
            <input id="searchInput" oninput="searchAll()" class="w-full bg-white/5 border border-white/10 rounded-xl px-4 py-2.5 pl-10 outline-none focus:border-violet-500 text-sm" placeholder="Поиск...">
            <svg class="w-5 h-5 text-slate-400 absolute left-3 top-1/2 -translate-y-1/2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/></svg>
          </div>
        </div>
        <div id="searchResults" class="hidden border-b" style="border-color: var(--border)"></div>
        <!-- Saved Messages -->
        <div class="border-b" style="border-color: var(--border)">
          <div class="flex items-center gap-3 p-3 cursor-pointer hover:bg-white/5 transition" onclick="openSavedMessages()">
            <div class="relative shrink-0">
              <div class="chat-avatar gradient-bg">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 5a2 2 0 012-2h10a2 2 0 012 2v16l-7-3.5L5 21V5z"/></svg>
              </div>
            </div>
            <div class="flex-1 min-w-0">
              <div class="font-medium">Избранное</div>
              <div class="text-sm text-slate-400">Сохраненные сообщения</div>
            </div>
          </div>
        </div>
        <div id="chatList" class="scrollbar"></div>
      </aside>
      <!-- Chat Area -->
      <main id="chatArea">
        <div id="emptyChat">
          <div class="text-center">
            <div class="w-24 h-24 bg-white/5 rounded-full mx-auto mb-4 grid place-items-center">
              <svg class="w-12 h-12 text-slate-500" fill="currentColor" viewBox="0 0 24 24"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H6l-2 2V4h16v12z"/></svg>
            </div>
            <h3 class="text-xl font-semibold text-slate-300">Выберите чат</h3>
            <p class="text-slate-500 mt-2">или создайте новый</p>
          </div>
        </div>
        <section id="activeChat">
          <div class="chat-header p-3 flex items-center gap-3">
            <button class="icon-btn md:hidden" onclick="closeChat()" title="Назад">
              <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/></svg>
            </button>
            <div id="chatAvatar" class="chat-avatar chat-avatar-sm gradient-bg"></div>
            <div class="flex-1 min-w-0">
              <h3 id="chatName" class="font-semibold truncate"></h3>
              <p id="chatStatus" class="text-xs text-slate-400 truncate"></p>
            </div>
            <div id="chatHeaderActions" class="flex gap-1 flex-shrink-0"></div>
          </div>
          <!-- Pinned Message -->
          <div id="pinnedMessage" class="hidden px-4 py-2 border-b" style="border-color: var(--border); background: rgba(139,92,246,0.1); cursor: pointer;" onclick="scrollToPinnedMessage()">
            <div class="flex items-center gap-2">
              <svg class="w-4 h-4 text-violet-400 shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 5a2 2 0 012-2h10a2 2 0 012 2v16l-7-3.5L5 21V5z"/></svg>
              <div class="flex-1 min-w-0">
                <div class="text-xs text-violet-400 font-medium">Закрепленное сообщение</div>
                <div id="pinnedMessageText" class="text-sm truncate"></div>
              </div>
              <button class="icon-btn" onclick="event.stopPropagation(); unpinMessage()" title="Открепить">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
              </button>
            </div>
          </div>
          <div id="messagesContainer" class="scrollbar"></div>
          <div id="typingIndicator" class="hidden px-4 py-2">
            <div class="flex items-center gap-2 text-slate-400 text-sm">
              <div class="flex gap-1">
                <span class="typing-dot"></span>
                <span class="typing-dot"></span>
                <span class="typing-dot"></span>
              </div>
              <span id="typingText">печатает...</span>
            </div>
          </div>
          <!-- Upload preview with caption + send -->
          <div id="uploadPreview" class="hidden px-3 py-3 border-t" style="border-color: var(--border); background: rgba(15,23,42,.9)">
            <div class="flex flex-col gap-2">
              <div class="flex items-start gap-3">
                <img id="uploadPreviewImage" src="" class="w-20 h-20 object-contain rounded-xl hidden" style="background: rgba(2,6,23,.55)" alt="preview">
                <div id="uploadPreviewFile" class="hidden items-center gap-2 p-2 bg-white/5 rounded-xl border border-white/10">
                  <svg class="w-8 h-8 text-violet-300" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/></svg>
                  <span id="uploadFileName" class="text-sm truncate max-w-[180px]"></span>
                </div>
                <button class="icon-btn ml-auto" onclick="cancelUpload()" title="Отмена">
                  <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
                </button>
              </div>
              <input id="imageCaption" class="w-full bg-white/5 border border-white/10 rounded-xl px-3 py-2 text-sm outline-none focus:border-violet-500" placeholder="Добавить подпись (Enter для отправки)..." onkeydown="if(event.key==='Enter'){event.preventDefault();sendFileWithCaption();}" />
              <div id="uploadProgress" class="h-2 bg-white/10 rounded-full overflow-hidden hidden">
                <div id="uploadProgressBar" class="h-full gradient-bg" style="width:0%"></div>
              
              <div class="flex justify-end">
                <button type="button" class="px-4 py-2 rounded-xl font-semibold gradient-bg shadow-lg hover:opacity-90" onclick="sendFileWithCaption()">Отправить</button>
              </div>
</div>
            </div>
          </div>
          <div id="messageInputArea">
            <div id="recordingIndicator" class="hidden mb-2">
              <div class="recording-indicator">
                <div class="recording-dot"></div>
                <span id="recordingTime">0:00</span>
                <button class="ml-auto text-xs px-3 py-1 bg-red-500/20 rounded-lg hover:bg-red-500/30" onclick="cancelRecording()">Отмена</button>
              </div>
            </div>
            <!-- Reply preview -->
            <div id="replyPreview" class="mb-2 px-3 py-2 rounded-xl border border-violet-500/30 bg-violet-500/10">
              <div class="flex items-start gap-2">
                <div class="flex-1 min-w-0">
                  <div id="replyAuthor" class="text-xs text-violet-400 font-medium"></div>
                  <div id="replyText" class="text-sm truncate"></div>
                </div>
                <button type="button" class="icon-btn" style="width:36px;height:36px;border-radius:12px" onclick="clearReplyTo()" title="Отменить ответ">✕</button>
              </div>
            </div>
            <form id="messageForm" onsubmit="sendMessage(event)">
              <input type="file" id="fileInput" class="hidden" accept="image/*,video/*,.pdf,.doc,.docx,.xls,.xlsx,.zip,.rar,.ppt,.pptx,.txt" onchange="handleFileSelect(event)">
              <button type="button" class="icon-btn" onclick="openFilePicker()" title="Прикрепить">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13"/></svg>
              </button>
              <button type="button" id="circleBtn" class="icon-btn" title="Удерживайте для записи кружка">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"/></svg>
              </button>
              <button type="button" id="voiceBtn" class="icon-btn" title="Удерживайте для записи голосового">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z"/></svg>
              </button>
              <button type="button" class="icon-btn" onclick="toggleEmoji()" title="Эмодзи">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.828 14.828a4 4 0 01-5.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>
              </button>
              <input id="messageInput" type="text" autocomplete="off" placeholder="Сообщение..." oninput="handleTyping()">
              <button class="send-btn" type="submit" title="Отправить">
                <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/></svg>
              </button>
            </form>
            <div id="emojiPicker">
              <div class="emoji-tabs">
                <button type="button" class="emoji-tab active" id="emojiTabSmileys" onclick="showEmojiCategory('smileys')">😀</button>
                <button type="button" class="emoji-tab" id="emojiTabGestures" onclick="showEmojiCategory('gestures')">👋</button>
                <button type="button" class="emoji-tab" id="emojiTabAnimals" onclick="showEmojiCategory('animals')">🐱</button>
                <button type="button" class="emoji-tab" id="emojiTabFood" onclick="showEmojiCategory('food')">🍕</button>
                <button type="button" class="emoji-tab" id="emojiTabActivities" onclick="showEmojiCategory('activities')">⚽</button>
                <button type="button" class="emoji-tab" id="emojiTabTravel" onclick="showEmojiCategory('travel')">🚗</button>
                <button type="button" class="emoji-tab" id="emojiTabObjects" onclick="showEmojiCategory('objects')">💡</button>
                <button type="button" class="emoji-tab" id="emojiTabSymbols" onclick="showEmojiCategory('symbols')">❤️</button>
              </div>
              <div id="emojiGrid" class="emoji-grid scrollbar"></div>
            </div>
          </div>
          <div id="channelNotice" class="px-4 py-4 text-center text-slate-400" style="display:none; border-top:1px solid var(--border); background:rgba(15,23,42,.9)">
            <svg class="w-6 h-6 mx-auto mb-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5.882V19.24a1.76 1.76 0 01-3.417.592l-2.147-6.15M18 13a3 3 0 100-6M5.436 13.683A4.001 4.001 0 017 6h1.832c4.1 0 7.625-1.234 9.168-3v14c-1.543-1.766-5.067-3-9.168-3H7a3.988 3.988 0 01-1.564-.317z"/></svg>
            Только администраторы могут писать в этот канал
          </div>
        </section>
      </main>
    </div>
    <!-- Toast -->
    <div id="toast" class="hidden" onclick="handleToastClick()">
      <div class="glass border" style="border-color:var(--border); border-radius:16px; padding:12px 14px; cursor:pointer;">
        <div class="flex items-center gap-3">
          <div id="toastIcon" class="w-10 h-10 rounded-full gradient-bg grid place-items-center font-bold shrink-0"></div>
          <div class="min-w-0">
            <div id="toastTitle" class="font-semibold truncate"></div>
            <div id="toastMessage" class="text-sm text-slate-400 truncate"></div>
          </div>
        </div>
      </div>
    </div>
    <!-- Message Context Menu -->
    <div id="messageContextMenu" class="fade-in">
      <button onclick="copyMessage()" id="copyMessageBtn" class="context-menu-btn">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"/></svg>
        <span>Скопировать</span>
      </button>
      <button onclick="togglePinMessage()" id="pinMessageBtn" class="context-menu-btn">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 5a2 2 0 012-2h10a2 2 0 012 2v16l-7-3.5L5 21V5z"/></svg>
        <span id="pinMessageText">Закрепить</span>
      </button>
      <button onclick="startEditMessage()" id="editMessageBtn" class="context-menu-btn">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"/></svg>
        <span>Редактировать</span>
      </button>
      <button onclick="deleteMessage()" id="deleteMessageBtn" class="context-menu-btn text-red-400">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/></svg>
        <span>Удалить</span>
      </button>
      <button onclick="startReplyFromMenu()" class="context-menu-btn"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h11a4 4 0 014 4v7m0 0l-4-4m4 4l4-4"/></svg><span>Ответить</span></button>
<button onclick="startForwardFromMenu()" class="context-menu-btn"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 12l1.41 1.41L11 7.83V20h2V7.83l5.59 5.58L20 12l-8-8-8 8z"/></svg><span>Переслать</span></button>
<div class="context-menu-divider"></div>
      <div class="flex gap-1 p-2">
        <button class="reaction-btn" onclick="addReaction('👍')">👍</button>
        <button class="reaction-btn" onclick="addReaction('❤️')">❤️</button>
        <button class="reaction-btn" onclick="addReaction('😂')">😂</button>
        <button class="reaction-btn" onclick="addReaction('😮')">😮</button>
        <button class="reaction-btn" onclick="addReaction('😢')">😢</button>
        <button class="reaction-btn" onclick="addReaction('🔥')">🔥</button>
      </div>
    </div>
    <!-- Confirm Delete Modal -->
    <div id="confirmModal">
      <div class="confirm-box">
        <div class="confirm-header">
          <div class="confirm-icon">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
            </svg>
          </div>
          <div class="confirm-title">Удалить сообщение?</div>
          <div class="confirm-text">Сообщение будет удалено для всех участников чата</div>
        </div>
        <div class="confirm-buttons">
          <button class="confirm-btn" onclick="closeConfirmModal()">Отмена</button>
          <button class="confirm-btn danger" onclick="confirmDeleteMessage()">Удалить</button>
        </div>
      </div>
    </div>
    <!-- Edit Message Modal -->
    <div id="editMessageModal" class="modal" onclick="modalBackdropClose(event, 'editMessageModal')">
      <div class="sheet p-4">
        <div class="flex justify-between items-center mb-4">
          <h3 class="text-lg font-bold">Редактировать сообщение</h3>
          <button class="icon-btn" onclick="closeModal('editMessageModal')">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
          </button>
        </div>
        <textarea id="editMessageText" class="w-full bg-white/5 border border-white/10 rounded-xl px-4 py-3 outline-none focus:border-violet-500 resize-none h-32" placeholder="Текст сообщения..."></textarea>
        <div class="flex gap-2 mt-4">
          <button class="flex-1 py-2.5 bg-white/5 rounded-xl text-slate-400 hover:bg-white/10" onclick="closeModal('editMessageModal')">Отмена</button>
          <button class="flex-1 py-2.5 gradient-bg rounded-xl font-semibold hover:opacity-95" onclick="saveEditedMessage()">Сохранить</button>
        </div>
      </div>
    </div>
    <!-- Image Viewer -->
    <div id="imageViewer" onclick="closeImageViewer()">
      <button class="absolute top-4 right-4 icon-btn" style="background: rgba(255,255,255,.1); border-color: rgba(255,255,255,.18)">
        <svg class="w-7 h-7" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
      </button>
      <img id="viewerImage" alt="view" class="max-w-full max-h-full object-contain" />
    </div>
    <!-- Create Menu Modal -->
    <div id="createMenuModal" class="modal" onclick="modalBackdropClose(event, 'createMenuModal')">
      <div class="sheet bottom p-4">
        <h3 class="text-lg font-bold mb-4 text-center">Создать</h3>
        <div class="space-y-2">
          <button class="w-full flex items-center gap-3 p-3 hover:bg-white/5 rounded-xl" onclick="showNewPrivateChat()">
            <div class="w-10 h-10 gradient-bg rounded-full grid place-items-center">
              <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"/></svg>
            </div>
            <div class="text-left">
              <div class="font-medium">Личный чат</div>
              <div class="text-xs text-slate-400">Написать пользователю</div>
            </div>
          </button>
          <button class="w-full flex items-center gap-3 p-3 hover:bg-white/5 rounded-xl" onclick="showSearchGroupsChannels()">
            <div class="w-10 h-10 gradient-bg rounded-full grid place-items-center" style="background: linear-gradient(135deg,#8b5cf6,#ec4899)">
              <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/></svg>
            </div>
            <div class="text-left">
              <div class="font-medium">Найти группы и каналы</div>
              <div class="text-xs text-slate-400">Поиск публичных сообществ</div>
            </div>
          </button>
          <button class="w-full flex items-center gap-3 p-3 hover:bg-white/5 rounded-xl" onclick="showCreateGroup()">
            <div class="w-10 h-10 gradient-green rounded-full grid place-items-center">
              <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"/></svg>
            </div>
            <div class="text-left">
              <div class="font-medium">Создать группу</div>
              <div class="text-xs text-slate-400">До 200 участников</div>
            </div>
          </button>
          <button class="w-full flex items-center gap-3 p-3 hover:bg-white/5 rounded-xl" onclick="showCreateChannel()">
            <div class="w-10 h-10 gradient-orange rounded-full grid place-items-center">
              <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5.882V19.24a1.76 1.76 0 01-3.417.592l-2.147-6.15M18 13a3 3 0 100-6M5.436 13.683A4.001 4.001 0 017 6h1.832c4.1 0 7.625-1.234 9.168-3v14c-1.543-1.766-5.067-3-9.168-3H7a3.988 3.988 0 01-1.564-.317z"/></svg>
            </div>
            <div class="text-left">
              <div class="font-medium">Создать канал</div>
              <div class="text-xs text-slate-400">Только вы можете писать</div>
            </div>
          </button>
        </div>
        <button class="w-full mt-4 py-2 text-slate-400 hover:text-white" onclick="closeModal('createMenuModal')">Отмена</button>
      </div>
    </div>
    <!-- Search Groups/Channels Modal -->
    <div id="searchGroupsChannelsModal" class="modal" onclick="modalBackdropClose(event, 'searchGroupsChannelsModal')">
      <div class="sheet p-4 max-h-[80vh] flex flex-col">
        <div class="flex justify-between items-center mb-4">
          <h3 class="text-lg font-bold">Найти группы и каналы</h3>
          <button class="icon-btn" onclick="closeModal('searchGroupsChannelsModal')">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
          </button>
        </div>
        <div class="flex gap-2 mb-3">
          <button id="searchTabGroups" class="flex-1 py-2 px-3 rounded-lg text-sm font-medium bg-violet-600 text-white" onclick="switchSearchTab('groups')">Группы</button>
          <button id="searchTabChannels" class="flex-1 py-2 px-3 rounded-lg text-sm font-medium text-slate-400" onclick="switchSearchTab('channels')">Каналы</button>
        </div>
        <input id="groupChannelSearchInput" oninput="searchGroupsChannels()" class="w-full bg-white/5 border border-white/10 rounded-xl px-4 py-2.5 mb-3 outline-none focus:border-violet-500" placeholder="Поиск...">
        <div id="groupChannelSearchResults" class="flex-1 overflow-auto scrollbar"></div>
      </div>
    </div>
    <!-- New Private Chat Modal -->
    <div id="newPrivateChatModal" class="modal" onclick="modalBackdropClose(event, 'newPrivateChatModal')">
      <div class="sheet p-4 max-h-[80vh] flex flex-col">
        <div class="flex justify-between items-center mb-4">
          <h3 class="text-lg font-bold">Новый чат</h3>
          <button class="icon-btn" onclick="closeModal('newPrivateChatModal')">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
          </button>
        </div>
        <input id="userSearchInput" oninput="searchUsersForChat()" class="w-full bg-white/5 border border-white/10 rounded-xl px-4 py-2.5 mb-3 outline-none focus:border-violet-500" placeholder="Поиск пользователей...">
        <div id="userSearchResults" class="flex-1 overflow-auto scrollbar"></div>
      </div>
    </div>
    <!-- Create Group Modal -->
    <div id="createGroupModal" class="modal" onclick="modalBackdropClose(event, 'createGroupModal')">
      <div class="sheet p-4 max-h-[86vh] flex flex-col">
        <div class="flex justify-between items-center mb-4">
          <h3 class="text-lg font-bold">Новая группа</h3>
          <button class="icon-btn" onclick="closeModal('createGroupModal')">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
          </button>
        </div>
        <input id="groupName" class="w-full bg-white/5 border border-white/10 rounded-xl px-4 py-2.5 mb-3 outline-none focus:border-violet-500" placeholder="Название группы">
        <input id="groupSearchInput" oninput="searchUsersForGroup()" class="w-full bg-white/5 border border-white/10 rounded-xl px-4 py-2.5 mb-3 outline-none focus:border-violet-500" placeholder="Добавить участников...">
        <div id="selectedMembers" class="flex flex-wrap gap-2 mb-3"></div>
        <div id="groupSearchResults" class="flex-1 overflow-auto scrollbar mb-3 min-h-[200px]"></div>
        <button class="w-full gradient-bg py-2.5 rounded-xl font-semibold hover:opacity-95" onclick="createGroup()">Создать группу</button>
      </div>
    </div>
    <!-- Create Channel Modal -->
    <div id="createChannelModal" class="modal" onclick="modalBackdropClose(event, 'createChannelModal')">
      <div class="sheet p-4">
        <div class="flex justify-between items-center mb-4">
          <h3 class="text-lg font-bold">Новый канал</h3>
          <button class="icon-btn" onclick="closeModal('createChannelModal')">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
          </button>
        </div>
        <input id="channelName" class="w-full bg-white/5 border border-white/10 rounded-xl px-4 py-2.5 mb-3 outline-none focus:border-violet-500" placeholder="Название канала">
        <textarea id="channelDescription" class="w-full bg-white/5 border border-white/10 rounded-xl px-4 py-2.5 mb-3 outline-none focus:border-violet-500 resize-none h-24" placeholder="Описание (необязательно)"></textarea>
        <button class="w-full gradient-bg py-2.5 rounded-xl font-semibold hover:opacity-95" onclick="createChannel()">Создать канал</button>
      </div>
    </div>
    <!-- Account Switcher Modal -->
    <div id="accountSwitcherModal" class="modal" onclick="modalBackdropClose(event, 'accountSwitcherModal')">
      <div class="sheet bottom p-4">
        <h3 class="text-lg font-bold mb-4">Аккаунты</h3>
        <div id="accountSwitcherList" class="space-y-2 max-h-64 overflow-auto scrollbar mb-4"></div>
        <button class="w-full flex items-center justify-center gap-2 p-3 border border-dashed border-white/20 rounded-xl text-slate-400 hover:border-violet-500 hover:text-violet-300" onclick="addNewAccount()">
          <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/></svg>
          Добавить аккаунт
        </button>
        <button class="w-full mt-3 py-2 text-slate-400 hover:text-white" onclick="closeModal('accountSwitcherModal')">Закрыть</button>
      </div>
    </div>
    <!-- Profile Modal -->
    <div id="profileModal" class="modal" onclick="modalBackdropClose(event, 'profileModal')">
      <div class="sheet p-6">
        <div class="flex justify-between items-center mb-6">
          <h3 class="text-xl font-bold">Профиль</h3>
          <button class="icon-btn" onclick="closeModal('profileModal')">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
          </button>
        </div>
        <div class="text-center mb-6">
          <label class="avatar-upload mx-auto block" style="width:96px;height:96px;position:relative;cursor:pointer;">
            <div id="profileAvatar" class="w-24 h-24 gradient-bg rounded-full grid place-items-center text-3xl font-bold" style="position:relative;">
              <span id="profileAvatarLetter"></span>
              <img id="profileAvatarImg" src="" class="hidden" alt="avatar" style="position:absolute;inset:0;width:100%;height:100%;object-fit:cover;border-radius:50%;">
            </div>
            <input type="file" id="profileAvatarInput" accept="image/*" onchange="handleProfileAvatarSelect(event)" style="position:absolute;inset:0;opacity:0;cursor:pointer;width:100%;height:100%;">
            <div class="avatar-upload-overlay">
              <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 0110.07 4h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0018.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z"/><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 13a3 3 0 11-6 0 3 3 0 016 0z"/></svg>
            </div>
          </label>
          <p class="text-xs text-slate-400 mb-2 mt-2">Нажмите для изменения аватарки</p>
          <div id="profileNameDisplay" class="text-xl font-semibold"></div>
          <div id="profileEmail" class="text-slate-400"></div>
        </div>
        <form class="space-y-4" onsubmit="updateProfile(event)">
          <input id="newProfileName" class="w-full bg-white/5 border border-white/10 rounded-xl px-4 py-3 outline-none focus:border-violet-500" placeholder="Новое имя">
          <input id="newProfileStatus" class="w-full bg-white/5 border border-white/10 rounded-xl px-4 py-3 outline-none focus:border-violet-500" placeholder="Статус">
          <button type="submit" class="w-full gradient-bg py-3 rounded-xl font-semibold hover:opacity-95">Сохранить</button>
        </form>
        <button class="w-full mt-3 py-3 bg-red-500/15 text-red-300 rounded-xl font-medium hover:bg-red-500/25" onclick="logout()">Выйти</button>
      </div>
    </div>
    <!-- App Settings Modal -->
    <div id="appSettingsModal" class="modal" onclick="modalBackdropClose(event, 'appSettingsModal')">
      <div class="sheet p-6 max-h-[90vh] overflow-auto scrollbar">
        <div class="flex justify-between items-center mb-6">
          <h3 class="text-xl font-bold">Настройки</h3>
          <button class="icon-btn" onclick="closeModal('appSettingsModal')">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
          </button>
        </div>
        <div class="space-y-6">
          <!-- Тема -->
          <div>
            <label class="block text-sm font-medium text-slate-300 mb-3">Тема оформления</label>
            <div class="grid grid-cols-3 gap-2">
              <button type="button" onclick="setTheme('dark')" id="themeDark" class="theme-btn p-3 rounded-xl border-2 border-white/10 hover:border-violet-500 transition-all">
                <div class="w-full h-16 rounded-lg mb-2" style="background: linear-gradient(135deg, #0b1220 0%, #1e293b 100%);"></div>
                <div class="text-xs font-medium">Тёмная</div>
              </button>
              <button type="button" onclick="setTheme('light')" id="themeLight" class="theme-btn p-3 rounded-xl border-2 border-white/10 hover:border-violet-500 transition-all">
                <div class="w-full h-16 rounded-lg mb-2" style="background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);"></div>
                <div class="text-xs font-medium">Светлая</div>
              </button>
              <button type="button" onclick="setTheme('auto')" id="themeAuto" class="theme-btn p-3 rounded-xl border-2 border-white/10 hover:border-violet-500 transition-all">
                <div class="w-full h-16 rounded-lg mb-2" style="background: linear-gradient(90deg, #0b1220 0%, #0b1220 50%, #f8fafc 50%, #f8fafc 100%);"></div>
                <div class="text-xs font-medium">Авто</div>
              </button>
            </div>
          </div>
          <!-- Микрофон -->
          <div>
            <label class="block text-sm font-medium text-slate-300 mb-2">Микрофон</label>
            <select id="microphoneSelect" class="w-full bg-white/5 border border-white/10 rounded-xl px-4 py-3 outline-none focus:border-violet-500" onchange="saveMicrophonePreference()">
              <option value="">По умолчанию</option>
            </select>
            <button type="button" onclick="testMicrophone()" class="mt-2 w-full py-2 bg-white/5 rounded-xl text-sm hover:bg-white/10 transition-all">
              🎤 Проверить микрофон
            </button>
          </div>
          <!-- Камера -->
          <div>
            <label class="block text-sm font-medium text-slate-300 mb-2">Камера</label>
            <select id="cameraSelect" class="w-full bg-white/5 border border-white/10 rounded-xl px-4 py-3 outline-none focus:border-violet-500" onchange="saveCameraPreference()">
              <option value="">По умолчанию</option>
            </select>
            <button type="button" onclick="testCamera()" class="mt-2 w-full py-2 bg-white/5 rounded-xl text-sm hover:bg-white/10 transition-all">
              📹 Проверить камеру
            </button>
          </div>
          <!-- Уведомления -->
          <div>
            <label class="block text-sm font-medium text-slate-300 mb-2">Уведомления</label>
            <div class="space-y-2">
              <label class="flex items-center gap-3 p-3 bg-white/5 rounded-xl cursor-pointer hover:bg-white/10 transition-all">
                <input type="checkbox" id="soundNotifications" onchange="saveNotificationSettings()" class="w-5 h-5 rounded accent-violet-600">
                <div class="flex-1">
                  <div class="text-sm font-medium">Звук уведомлений</div>
                  <div class="text-xs text-slate-400">Воспроизводить звук при новых сообщениях</div>
                </div>
              </label>
              <label class="flex items-center gap-3 p-3 bg-white/5 rounded-xl cursor-pointer hover:bg-white/10 transition-all">
                <input type="checkbox" id="desktopNotifications" onchange="saveNotificationSettings()" class="w-5 h-5 rounded accent-violet-600">
                <div class="flex-1">
                  <div class="text-sm font-medium">Системные уведомления</div>
                  <div class="text-xs text-slate-400">Показывать уведомления на рабочем столе</div>
                </div>
              </label>
            </div>
          </div>
          <!-- Информация -->
          <div class="pt-4 border-t border-white/10">
            <div class="text-center text-sm text-slate-400">
              <div class="mb-2">FlashChat Pro v2.0</div>
              <div class="text-xs">© 2025 Все права защищены</div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <!-- Microphone Test Modal -->
    <div id="micTestModal" class="modal" onclick="modalBackdropClose(event, 'micTestModal')">
      <div class="sheet p-6">
        <div class="flex justify-between items-center mb-6">
          <h3 class="text-lg font-bold">Проверка микрофона</h3>
          <button class="icon-btn" onclick="closeModal('micTestModal')">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
          </button>
        </div>
        <div class="text-center">
          <div class="w-32 h-32 mx-auto mb-4 rounded-full bg-gradient-to-br from-violet-500 to-purple-600 flex items-center justify-center">
            <svg id="micTestIcon" class="w-16 h-16 text-white" fill="currentColor" viewBox="0 0 24 24"><path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/><path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/></svg>
          </div>
          <div id="micTestLevel" class="h-4 bg-white/10 rounded-full overflow-hidden mb-4">
            <div id="micTestBar" class="h-full bg-gradient-to-r from-green-500 to-violet-500 transition-all duration-100" style="width:0%"></div>
          </div>
          <p id="micTestStatus" class="text-slate-400 mb-4">Говорите в микрофон...</p>
          <button onclick="stopMicTest()" class="px-6 py-2 bg-red-500/20 text-red-300 rounded-xl hover:bg-red-500/30">Остановить</button>
        </div>
      </div>
    </div>
    <!-- Camera Test Modal -->
    <div id="cameraTestModal" class="modal" onclick="modalBackdropClose(event, 'cameraTestModal')">
      <div class="sheet p-6">
        <div class="flex justify-between items-center mb-6">
          <h3 class="text-lg font-bold">Проверка камеры</h3>
          <button class="icon-btn" onclick="closeModal('cameraTestModal')">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
          </button>
        </div>
        <div class="text-center">
          <video id="cameraTestVideo" autoplay playsinline class="w-full max-w-md mx-auto rounded-xl bg-black mb-4" style="max-height:400px;"></video>
          <p class="text-slate-400 mb-4">Проверьте изображение с камеры</p>
          <button onclick="stopCameraTest()" class="px-6 py-2 bg-red-500/20 text-red-300 rounded-xl hover:bg-red-500/30">Остановить</button>
        </div>
      </div>
    </div>
    <!-- Settings Modal (group/channel) -->
    <div id="settingsModal" class="modal" onclick="modalBackdropClose(event, 'settingsModal')">
      <div class="sheet p-6 max-h-[90vh] overflow-auto scrollbar">
        <div class="flex justify-between items-center mb-6">
          <h3 id="settingsTitle" class="text-xl font-bold">Настройки</h3>
          <button class="icon-btn" onclick="closeModal('settingsModal')">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
          </button>
        </div>
        <div class="space-y-4">
          <!-- Avatar upload -->
          <div class="flex justify-center mb-4">
            <div class="avatar-upload">
              <div id="settingsAvatar" class="chat-avatar chat-avatar-lg gradient-bg cursor-pointer">
                <span id="settingsAvatarLetter"></span>
                <img id="settingsAvatarImg" src="" class="hidden" alt="avatar">
              </div>
              <input type="file" id="settingsAvatarInput" accept="image/*" onchange="handleAvatarSelect(event)">
              <div class="avatar-upload-overlay">
                <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 0110.07 4h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0018.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z"/><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 13a3 3 0 11-6 0 3 3 0 016 0z"/></svg>
              </div>
            </div>
          </div>
          <p class="text-center text-xs text-slate-400 -mt-2 mb-4">Нажмите для изменения аватарки</p>
          <div>
            <label class="block text-sm text-slate-400 mb-1">Название</label>
            <input id="settingsName" class="w-full bg-white/5 border border-white/10 rounded-xl px-4 py-3 outline-none focus:border-violet-500">
          </div>
          <div id="settingsDescriptionBlock">
            <label class="block text-sm text-slate-400 mb-1">Описание</label>
            <textarea id="settingsDescription" class="w-full bg-white/5 border border-white/10 rounded-xl px-4 py-3 outline-none focus:border-violet-500 resize-none h-24"></textarea>
          </div>
          <div id="settingsMembersBlock">
            <label class="block text-sm text-slate-400 mb-2">Участники (<span id="settingsMemberCount">0</span>)</label>
            <div id="settingsMembersList" class="space-y-2 max-h-56 overflow-auto scrollbar"></div>
          </div>
          <button class="w-full gradient-bg py-3 rounded-xl font-semibold hover:opacity-95" onclick="saveSettings()">Сохранить</button>
          <button class="w-full py-3 bg-red-500/15 text-red-300 rounded-xl font-medium hover:bg-red-500/25" onclick="deleteGroupOrChannel()"><span id="deleteButtonText">Удалить</span></button>
        </div>
      </div>
    </div>
  </div>
  <script>
    // ====== CONFIG ======
    const IMGBB_API_KEY = 'f457bea1a8c6cf16c4a03634c8ea3177';
    const DEVELOPER_EMAILS = [
      'stepanu142z@gmail.com',
      'Stepan42z@yandex.ru'
    ];
    function isDeveloper(email){
      if(!email) return false;
      return DEVELOPER_EMAILS.some(e => e.toLowerCase() === String(email).toLowerCase());
    }
    function getDevBadgeHtml(){
      return `<span class="dev-badge"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm-2 16l-4-4 1.41-1.41L10 14.17l6.59-6.59L18 9l-8 8z"/></svg>DEV</span>`;
    }
    function getNameWithBadge(name, email){
      const safeName = escapeHtml(name || '');
      return isDeveloper(email) ? safeName + ' ' + getDevBadgeHtml() : safeName;
    }
    const firebaseConfig = {
      apiKey: "AIzaSyBeLAiCwZjij3d6FZ4OzylJnaxPwlyf1Ag",
      authDomain: "webchat-28b64.firebaseapp.com",
      databaseURL: "https://webchat-28b64-default-rtdb.europe-west1.firebasedatabase.app",
      projectId: "webchat-28b64",
      storageBucket: "webchat-28b64.firebasestorage.app",
      messagingSenderId: "307131215178",
      appId: "1:307131215178:web:0e510297256e30959825b3",
      measurementId: "G-JD21B447LF"
    };
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const database = firebase.database();
    // Storage disabled - using tmpfiles.org/catbox.moe for file uploads
    // const storage = firebase.storage();
    // ====== STATE ======
    let currentUser = null;
    let currentUserData = null;
    let currentChat = null;
    let currentChatType = null;
    let currentChatData = null;
    let typingTimeout = null;
    let unreadCounts = {};
    let selectedGroupMembers = [];
    let currentMessageId = null;
    let currentTab = 'all';
    let allChats = [];
    let allUsers = {};
    let toastChatId = null;
    let pendingFile = null;
    let uploadTask = null;
    let isUploading = false;
    let pendingAvatarFile = null;
    let notificationSound = null;
    let audioContext = null;
    let mediaRecorder = null;
    let audioChunks = [];
    let recordingStartTime = null;
    let recordingInterval = null;
    let currentPlayingAudio = null;
    // ====== NOTIFICATION SOUND ======
    function initNotificationSound() {
      try {
        // Создаём AudioContext для генерации звука
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        notificationSound = true;
        console.log('Notification sound initialized');
      } catch(e) {
        console.warn('Web Audio API not supported:', e);
        notificationSound = false;
      }
    }
    function playNotificationSound() {
      if (!audioContext || !notificationSound) return;
      try {
        // Разблокируем AudioContext если он заблокирован
        if (audioContext.state === 'suspended') {
          audioContext.resume();
        }
        // Создаём звук уведомления (два коротких тона как в Telegram)
        const now = audioContext.currentTime;
        // Первый тон
        const osc1 = audioContext.createOscillator();
        const gain1 = audioContext.createGain();
        osc1.connect(gain1);
        gain1.connect(audioContext.destination);
        osc1.frequency.value = 880; // Нота A5
        osc1.type = 'sine';
        gain1.gain.setValueAtTime(0.3, now);
        gain1.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc1.start(now);
        osc1.stop(now + 0.1);
        // Второй тон (чуть выше)
        const osc2 = audioContext.createOscillator();
        const gain2 = audioContext.createGain();
        osc2.connect(gain2);
        gain2.connect(audioContext.destination);
        osc2.frequency.value = 1100; // Нота C#6
        osc2.type = 'sine';
        gain2.gain.setValueAtTime(0.3, now + 0.12);
        gain2.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
        osc2.start(now + 0.12);
        osc2.stop(now + 0.25);
      } catch(e) {
        console.warn('Error playing notification sound:', e);
      }
    }
    // Запрос разрешения на уведомления - вызывается после действия пользователя
    function requestNotificationPermission() {
      if (!('Notification' in window)) {
        console.log('Браузер не поддерживает уведомления');
        return;
      }
      if (Notification.permission === 'default') {
        // Показываем кнопку для запроса разрешения
        showNotificationPrompt();
      }
    }
    function showNotificationPrompt() {
      // Создаём красивый баннер для запроса разрешения
      const banner = document.createElement('div');
      banner.id = 'notificationBanner';
      banner.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 16px;
        padding: 16px 20px;
        display: flex;
        align-items: center;
        gap: 12px;
        z-index: 1000;
        box-shadow: 0 10px 40px rgba(102,126,234,0.4);
        max-width: 90%;
        animation: slideDown 0.3s ease;
      `;
      banner.innerHTML = `
        <svg width="24" height="24" fill="white" viewBox="0 0 24 24">
          <path d="M12 22c1.1 0 2-.9 2-2h-4c0 1.1.9 2 2 2zm6-6v-5c0-3.07-1.63-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.64 5.36 6 7.92 6 11v5l-2 2v1h16v-1l-2-2zm-2 1H8v-6c0-2.48 1.51-4.5 4-4.5s4 2.02 4 4.5v6z"/>
        </svg>
        <div style="flex:1;min-width:0;">
          <div style="font-weight:600;font-size:14px;">Включить уведомления?</div>
          <div style="font-size:12px;opacity:0.9;">Узнавайте о новых сообщениях</div>
        </div>
        <button id="allowNotifBtn" style="background:white;color:#667eea;border:none;padding:8px 16px;border-radius:10px;font-weight:600;font-size:13px;cursor:pointer;">
          Включить
        </button>
        <button id="denyNotifBtn" style="background:transparent;color:white;border:1px solid rgba(255,255,255,0.3);padding:8px 12px;border-radius:10px;font-size:13px;cursor:pointer;">
          Позже
        </button>
      `;
      // Добавляем анимацию
      const style = document.createElement('style');
      style.textContent = `
        @keyframes slideDown {
          from { opacity: 0; transform: translateX(-50%) translateY(-20px); }
          to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }
      `;
      document.head.appendChild(style);
      document.body.appendChild(banner);
      document.getElementById('allowNotifBtn').onclick = async () => {
        try {
          const permission = await Notification.requestPermission();
          console.log('Notification permission:', permission);
          if (permission === 'granted') {
            showToast('🔔', 'Уведомления включены', 'Вы будете получать уведомления о новых сообщениях');
          }
        } catch(e) {
          console.error('Error requesting notification permission:', e);
        }
        banner.remove();
      };
      document.getElementById('denyNotifBtn').onclick = () => {
        banner.remove();
        // Запомним, что пользователь отказался (на 24 часа)
        localStorage.setItem('notifPromptDismissed', Date.now().toString());
      };
      // Автоматически скрываем через 15 секунд
      setTimeout(() => {
        if (document.getElementById('notificationBanner')) {
          banner.remove();
        }
      }, 15000);
    }
    // Разблокируем аудио при первом взаимодействии пользователя
    function unlockAudio() {
      if (audioContext && audioContext.state === 'suspended') {
        audioContext.resume();
      }
      // Удаляем слушатели после первого взаимодействия
      document.removeEventListener('click', unlockAudio);
      document.removeEventListener('touchstart', unlockAudio);
      document.removeEventListener('keydown', unlockAudio);
    }
    document.addEventListener('click', unlockAudio);
    document.addEventListener('touchstart', unlockAudio);
    document.addEventListener('keydown', unlockAudio);
    // ====== EMOJI DATA (large, TG-like categories) ======
    const EMOJI = {
      smileys: "😀 😃 😄 😁 😆 😅 😂 🤣 😊 😇 🙂 🙃 😉 😌 😍 🥰 😘 😗 😙 😚 😋 😛 😝 😜 🤪 🤨 🧐 🤓 😎 🥸 🤩 🥳 😏 😒 😞 😔 😟 😕 🙁 ☹️ 😣 😖 😫 😩 🥺 😢 😭 😤 😠 😡 🤬 😳 🥵 🥶 😱 😨 😰 😥 😓 🤗 🤭 🤫 🤔 🤐 😐 😑 😶 🫥 😬 🙄 😯 😦 😧 😮 😲 🥱 😴 🤤 😪 😵 🤯 🤠 🥴 🤮 🤢 🤧 🤒 🤕 🫠 🫡".split(" "),
      gestures: "👋 🤚 🖐️ ✋ 🖖 👌 🤌 🤏 ✌️ 🤞 🤟 🤘 🤙 🫵 👈 👉 👆 🖕 👇 ☝️ 👍 👎 ✊ 👊 🤛 🤜 👏 🙌 👐 🤲 🤝 🙏 ✍️ 💅 🤳 💪 🦾 🦿 🦵 🦶 👂 🦻 👃 🧠 🫀 🫁 👀 👁️ 👅 👄 💋".split(" "),
      animals: "🐶 🐱 🐭 🐹 🐰 🦊 🐻 🐼 🐻‍❄️ 🐨 🐯 🦁 🐮 🐷 🐽 🐸 🐵 🙈 🙉 🙊 🐒 🐔 🐧 🐦 🐤 🐣 🐥 🦆 🦅 🦉 🦇 🐺 🐗 🐴 🦄 🐝 🪲 🐛 🦋 🐌 🐞 🐜 🦟 🪰 🪱 🐢 🐍 🦎 🐙 🦑 🦐 🦞 🦀 🐡 🐠 🐟 🐬 🐳 🐋 🦈 🐊".split(" "),
      food: "🍏 🍎 🍐 🍊 🍋 🍌 🍉 🍇 🍓 🫐 🍈 🍒 🍑 🥭 🍍 🥥 🥝 🍅 🥑 🍆 🥔 🥕 🌽 🌶️ 🫑 🥒 🥬 🥦 🧄 🧅 🍄 🥜 🫘 🌰 🍞 🥐 🥖 🫓 🥨 🧀 🥚 🍳 🧈 🥞 🧇 🥓 🥩 🍗 🍖 🌭 🍔 🍟 🍕 🥪 🥙 🧆 🌮 🌯 🥗 🥘 🍝 🍜 🍲 🍛 🍣 🍱 🍙 🍚 🍘 🍥 🥟 🥠 🥡 🍢 🍡 🍧 🍨 🍦 🥧 🧁 🍰 🎂 🍮 🍭 🍬 🍫 🍿 🍩 🍪 ☕ 🍵 🧃 🥤 🧋 🍺 🍻 🥂 🍷 🍸 🍹 🧉".split(" "),
      activities: "⚽ 🏀 🏈 ⚾ 🥎 🎾 🏐 🏉 🥏 🎱 🪀 🏓 🏸 🏒 🏑 🥍 🏏 ⛳ 🪁 🏹 🎣 🤿 🥊 🥋 🎽 🛹 🛷 ⛸️ 🥌 🎿 ⛷️ 🏂 🏋️ 🤼 🤸 ⛹️ 🤺 🏇 🧘 🏄 🏊 🚴 🚵 🧗 🎪 🎭 🎨 🎬 🎤 🎧 🎼 🎹 🥁 🎷 🎺 🎸 🎻 🎲 ♟️ 🎯 🎳 🎮 🕹️ 🎰 🧩".split(" "),
      travel: "🚗 🚕 🚙 🚌 🚎 🏎️ 🚓 🚑 🚒 🚐 🛻 🚚 🚛 🚜 🏍️ 🛵 🚲 🛴 🚁 ✈️ 🛩️ 🚀 🛸 🚢 ⛵ 🚤 🛥️ 🚂 🚃 🚄 🚅 🚆 🚇 🚈 🚉 🗺️ 🧭 🏔️ ⛰️ 🌋 🗻 🏕️ 🏖️ 🏜️ 🏝️ 🏟️ 🏛️ 🏗️ 🧱 🏠 🏡 🏢 🏣 🏥 🏦 🏨 🏩 🏪 🏫 🏬 🏭 🗼 🗽 ⛪ 🕌 🛕 ⛩️ 🌉 🌌 🌠".split(" "),
      objects: "⌚ 📱 💻 ⌨️ 🖥️ 🖨️ 🖱️ 🖲️ 💽 💾 💿 📀 📷 📸 📹 🎥 📽️ 📺 📻 🎙️ 🎚️ 🎛️ 📞 ☎️ 📟 📠 🔋 🔌 💡 🔦 🕯️ 🪔 🧯 🛢️ 💸 💵 💴 💶 💷 💰 💳 💎 ⚖️ 🔧 🔨 ⚒️ 🛠️ ⛏️ 🪓 🔩 ⚙️ 🗜️ 🔗 ⛓️ 🧰 🧲 🔒 🔓 🔑 🗝️ 🔐 🧳 📦 📫 📬 📭 📮 ✉️ 📧 📨 📝 📁 📂 🗂️ 📅 📆 📊 📈 📉 📋 📌 📍".split(" "),
      symbols: "❤️ 🧡 💛 💚 💙 💜 🖤 🤍 🤎 💔 ❣️ 💕 💞 💓 💗 💖 💘 💝 💟 ☮️ ✝️ ☪️ 🕉️ ☯️ ✡️ 🔯 ♈ ♉ ♊ ♋ ♌ ♍ ♎ ♏ ♐ ♑ ♒ ♓ ⛎ 🔀 🔁 🔂 ▶️ ⏩ ⏭️ ⏯️ ◀️ ⏪ 🔼 ⏫ 🔽 ⏬ ⏸️ ⏹️ ⏺️ 🔆 🔅 📶 📳 📴 ✖️ ➕ ➖ ➗ ♾️ 💲 💱 ™️ ©️ ®️ 〰️ ➰ ➿ ✔️ ☑️ 🔘 🔴 🟠 🟡 🟢 🔵 🟣 ⚫ ⚪ 🟤 🔺 🔻 🔸 🔹 🔶 🔷 🔳 🔲 ▪️ ▫️ ◾ ◽ ⬛ ⬜ 🔔 🔕 🔊 🔇 💬 💭 🗯️ 🔥 ✨ 🎉 💯 ⭐ 🌟 💫 ⚡ 💥 🎊 🎁 🏆 🥇 🥈 🥉 🏅 🎖️ 🎗️".split(" ")
    };
    // ====== UI HELPERS ======
    function $(id){ return document.getElementById(id); }
    function showModal(id){ $(id).classList.add('show'); }
    function closeModal(id){ $(id).classList.remove('show'); }
    function modalBackdropClose(e, id){
      if(e.target && e.target.id === id) closeModal(id);
    }
    function showToast(icon, title, msg, chatId=null){
      toastChatId = chatId;
      $('toastIcon').textContent = icon;
      $('toastTitle').textContent = title;
      $('toastMessage').textContent = msg;
      const t = $('toast');
      t.classList.remove('hidden');
      clearTimeout(t._timer);
      t._timer = setTimeout(()=> t.classList.add('hidden'), 4000);
    }
    function handleToastClick(){
      $('toast').classList.add('hidden');
      if(toastChatId){
        const chat = allChats.find(c => c.id === toastChatId);
        if(chat) openChat(toastChatId, chat.type);
      }
    }
    function escapeHtml(text){
      const div = document.createElement('div');
      div.textContent = text ?? '';
      return div.innerHTML;
    }
    
function normalizeAudioDuration(d){
  if(d==null) return '0:00';
  if(typeof d==='number'){
    let sec = d>1e6 ? Math.round(d/1000) : Math.round(d);
    if(!isFinite(sec) || sec<0) sec=0;
    const m=Math.floor(sec/60), s=sec%60;
    return `${m}:${String(s).padStart(2,'0')}`;
  }
  const str=String(d);
  const m=str.match(/^(\d+):(\d{1,2})$/);
  if(m){
    const mm=parseInt(m[1],10), ss=parseInt(m[2],10);
    if(!isFinite(mm)||!isFinite(ss)||mm>9999||ss>59) return '0:00';
    return `${mm}:${String(ss).padStart(2,'0')}`;
  }
  // try parse seconds in string
  const num=parseFloat(str.replace(',','.'));
  if(isFinite(num)) return normalizeAudioDuration(num);
  return '0:00';
}

function getBlobAudioDuration(blob){
  return new Promise((resolve)=>{
    try{
      const url = URL.createObjectURL(blob);
      const a = new Audio();
      a.preload='metadata';
      a.onloadedmetadata=()=>{const d=a.duration;URL.revokeObjectURL(url);resolve(isFinite(d)?d:0);};
      a.onerror=()=>{URL.revokeObjectURL(url);resolve(0);};
      a.src=url;
    }catch(e){resolve(0);}
  });
}
function formatTime(ts){
      if(!ts) return '';
      const d = new Date(ts);
      const now = new Date();
      if(d.toDateString() === now.toDateString()){
        return d.toLocaleTimeString('ru-RU',{hour:'2-digit', minute:'2-digit'});
      }
      return d.toLocaleDateString('ru-RU',{day:'numeric', month:'short'});
    }
    function formatLastSeen(ts){
      if(!ts) return 'давно';
      const diff = Date.now() - ts;
      if(diff < 60000) return 'только что';
      if(diff < 3600000) return `${Math.floor(diff/60000)} мин назад`;
      if(diff < 86400000) return `${Math.floor(diff/3600000)} ч назад`;
      return new Date(ts).toLocaleDateString('ru-RU');
    }
    // ====== AUTH UI ======
    function showTab(tab){
      $('loginForm').classList.toggle('hidden', tab !== 'login');
      $('registerForm').classList.toggle('hidden', tab !== 'register');
      $('loginTab').classList.toggle('bg-violet-600', tab === 'login');
      $('loginTab').classList.toggle('text-white', tab === 'login');
      $('loginTab').classList.toggle('text-slate-400', tab !== 'login');
      $('registerTab').classList.toggle('bg-violet-600', tab === 'register');
      $('registerTab').classList.toggle('text-white', tab === 'register');
      $('registerTab').classList.toggle('text-slate-400', tab !== 'register');
    }
    function getErrorMessage(code){
      const messages = {
        'auth/email-already-in-use': 'Email уже используется',
        'auth/invalid-email': 'Неверный формат email',
        'auth/weak-password': 'Пароль слишком слабый (мин. 6 символов)',
        'auth/user-not-found': 'Пользователь не найден',
        'auth/wrong-password': 'Неверный пароль',
        'auth/invalid-credential': 'Неверный email или пароль',
        'auth/too-many-requests': 'Слишком много попыток. Подождите немного',
        'auth/network-request-failed': 'Ошибка сети. Проверьте интернет',
        'auth/operation-not-allowed': 'Операция не разрешена',
        'auth/user-disabled': 'Аккаунт заблокирован',
        'auth/requires-recent-login': 'Требуется повторный вход',
        'auth/missing-password': 'Введите пароль',
        'auth/missing-email': 'Введите email'
      };
      return messages[code] || null;
    }
    function showAuthError(msg){
      const el = $('authError');
      el.textContent = msg;
      el.classList.remove('hidden');
      clearTimeout(el._timer);
      el._timer = setTimeout(()=> el.classList.add('hidden'), 4000);
    }
    // Accounts storage
    function loadSavedAccounts(){
      const accounts = JSON.parse(localStorage.getItem('flashchat_accounts') || '[]');
      const container = $('savedAccounts');
      const list = $('accountsList');
      if(accounts.length){
        container.classList.remove('hidden');
        list.innerHTML = accounts.map(acc => {
          const nameWithBadge = isDeveloper(acc.email) ? escapeHtml(acc.name||acc.email) + ' ' + getDevBadgeHtml() : escapeHtml(acc.name||acc.email);
          return `
            <div class="saved-acc-row flex items-center gap-3 p-2.5 pl-4">
              <div class="saved-acc-avatar w-9 h-9 rounded-full grid place-items-center font-bold text-sm text-white">${escapeHtml((acc.name||'?').charAt(0).toUpperCase())}</div>
              <div class="flex-1 min-w-0">
                <div class="font-medium text-sm truncate">${nameWithBadge}</div>
                <div class="text-xs text-slate-400 truncate">${escapeHtml(acc.email)}</div>
              </div>
              <button class="saved-acc-login text-xs px-3 py-1.5 rounded-xl text-white" onclick="quickLogin('${escapeHtml(acc.email)}','${escapeHtml(acc.password)}')">Войти</button>
              <button class="text-slate-400 hover:text-red-300 p-1.5 rounded-lg hover:bg-white/5" onclick="removeAccount('${escapeHtml(acc.email)}')">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
              </button>
            </div>
          `;
        }).join('');
      } else {
        container.classList.add('hidden');
        list.innerHTML = '';
      }
    }
    function saveAccount(email,password,name){
      let accounts = JSON.parse(localStorage.getItem('flashchat_accounts') || '[]');
      accounts = accounts.filter(a => a.email !== email);
      accounts.unshift({email,password,name});
      if(accounts.length > 5) accounts = accounts.slice(0,5);
      localStorage.setItem('flashchat_accounts', JSON.stringify(accounts));
    }
    function removeAccount(email){
      let accounts = JSON.parse(localStorage.getItem('flashchat_accounts') || '[]');
      accounts = accounts.filter(a => a.email !== email);
      localStorage.setItem('flashchat_accounts', JSON.stringify(accounts));
      loadSavedAccounts();
    }
    function quickLogin(email,password){
      $('loginEmail').value = email;
      $('loginPassword').value = password;
      login(new Event('submit'));
    }
    // ====== NAV ======
    function showAuthScreen(){
      $('authScreen').style.display = 'block';
      $('chatScreen').classList.remove('active');
      $('chatScreen').style.display = 'none';
    }
    function showChatScreen(){
      $('authScreen').style.display = 'none';
      $('chatScreen').style.display = '';
      $('chatScreen').classList.add('active');
      // reset panels
      $('sidebar').style.display = 'flex';
      $('chatArea').classList.remove('active');
      $('chatArea').style.display = window.innerWidth <= 768 ? 'none' : 'flex';
      $('emptyChat').style.display = 'flex';
      $('activeChat').classList.remove('active');
      renderChatList();
    }
    function clearAllData(){
      // Очищаем все данные предыдущего пользователя
      currentChat = null;
      currentChatType = null;
      currentChatData = null;
      allChats = [];
      allUsers = {};
      unreadCounts = {};
      avatarCache.clear();
      // Отписываемся от всех слушателей
      database.ref('users').off();
      if(currentUser){
        database.ref(`userChats/${currentUser.uid}`).off();
        database.ref(`messages/${currentChat}`).off();
      }
      // Очищаем UI
      showLoadingChats();
      $('messagesContainer').innerHTML = '';
      $('activeChat').classList.remove('active');
      $('emptyChat').style.display = 'flex';
      // Закрываем все модальные окна
      ['createMenuModal','newPrivateChatModal','createGroupModal','createChannelModal','accountSwitcherModal','profileModal','appSettingsModal','settingsModal','editMessageModal','micTestModal','cameraTestModal'].forEach(id => {
        const modal = $(id);
        if(modal) modal.classList.remove('show');
      });
    }
    function showLoadingChats(){
      $('chatList').innerHTML = `
        <div class="p-6 text-center">
          <div class="w-16 h-16 mx-auto mb-4 rounded-full bg-gradient-to-br from-violet-500 to-purple-600 flex items-center justify-center animate-pulse">
            <svg class="w-8 h-8 text-white" fill="currentColor" viewBox="0 0 24 24"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H6l-2 2V4h16v12z"/></svg>
          </div>
          <div class="text-slate-400 font-medium mb-2">Загрузка чатов...</div>
          <div class="text-sm text-slate-500">Пожалуйста, подождите</div>
        </div>
      `;
    }
    function closeChat(){
      const prevChat = currentChat;
      currentChat = null;
      currentChatType = null;
      currentChatData = null;
      // Stop listeners for messages + typing
      if(prevChat){
        database.ref(`messages/${prevChat}`).off();
        database.ref(`typing/${prevChat}`).off();
      }
      $('activeChat').classList.remove('active');
      $('emptyChat').style.display = 'flex';
      if(window.innerWidth <= 768){
        $('chatArea').classList.remove('active');
        $('chatArea').style.display = 'none';
        $('sidebar').style.display = 'flex';
      }
    }
    // ====== FIREBASE auth ======
    // Инициализируем звук уведомлений
    initNotificationSound();
    // Запрашиваем разрешение на уведомления
    requestNotificationPermission();
    auth.onAuthStateChanged(async user => {
      if(user){
        // Проверяем, забанен ли пользователь
        const banSnap = await database.ref(`bannedUsers/${user.uid}`).once('value');
        if(banSnap.exists()){
          const banData = banSnap.val();
          showToast('🚫', 'Доступ запрещен', 'Ваш аккаунт заблокирован администратором');
          await auth.signOut();
          return;
        }
        // Очищаем данные предыдущего пользователя
        clearAllData();
        currentUser = user;
        // Показываем экран чата с индикатором загрузки
        showChatScreen();
        showLoadingChats();
        // Загружаем данные
        await loadUserData();
        await loadAllUsers();
        updateOnlineStatus(true);
        setupPresenceOnDisconnect();
        loadAllChats();
        setupNotificationListener();
        // Запрос разрешения на уведомления (с задержкой, чтобы не раздражать)
        setTimeout(() => {
          // Проверяем, не отказался ли пользователь ранее
          const dismissed = localStorage.getItem('notifPromptDismissed');
          if (dismissed) {
            const dismissedTime = parseInt(dismissed);
            // Показываем снова через 24 часа
            if (Date.now() - dismissedTime < 24 * 60 * 60 * 1000) {
              return;
            }
          }
          if ('Notification' in window && Notification.permission === 'default') {
            showNotificationPrompt();
          }
        }, 3000); // Показываем через 3 секунды после входа
      } else {
        currentUser = null;
        currentUserData = null;
        showAuthScreen();
      }
    });
    async function login(e){
      e.preventDefault();
      const email = $('loginEmail').value.trim();
      const password = $('loginPassword').value;
      const save = $('saveAccount').checked;
      if(!email) return showAuthError('Введите email');
      if(!password) return showAuthError('Введите пароль');
      try{
        console.log('Logging in:', email);
        await auth.signInWithEmailAndPassword(email, password);
        console.log('Login successful');
        if(save){
          const snap = await database.ref(`users/${auth.currentUser.uid}`).once('value');
          const userData = snap.val();
          saveAccount(email, password, userData?.name || email);
          loadSavedAccounts();
        }
      } catch(err){
        console.error('Login error:', err);
        showAuthError(getErrorMessage(err.code) || err.message || 'Ошибка входа');
      }
    }
    async function register(e){
      e.preventDefault();
      const name = $('registerName').value.trim();
      const email = $('registerEmail').value.trim();
      const password = $('registerPassword').value;
      if(!name) return showAuthError('Введите имя');
      if(!email) return showAuthError('Введите email');
      if(!password || password.length < 6) return showAuthError('Пароль должен быть минимум 6 символов');
      try{
        console.log('Registering user:', email);
        const cred = await auth.createUserWithEmailAndPassword(email, password);
        console.log('User created:', cred.user.uid);
        await database.ref(`users/${cred.user.uid}`).set({
          name,
          nameLower: name.toLowerCase(),
          email,
          status: 'Привет! Я использую FlashChat',
          online: true,
          createdAt: firebase.database.ServerValue.TIMESTAMP
        });
        console.log('User data saved to database');
        saveAccount(email, password, name);
        loadSavedAccounts();
        showToast('✅', 'Успешно', 'Аккаунт создан!');
      } catch(err){
        console.error('Registration error:', err);
        showAuthError(getErrorMessage(err.code) || err.message || 'Ошибка регистрации');
      }
    }
    function logout(){
      updateOnlineStatus(false);
      auth.signOut();
      closeModal('profileModal');
    }
    async function loadUserData(){
      const snap = await database.ref(`users/${currentUser.uid}`).once('value');
      currentUserData = snap.val() || {};
    }
    async function loadAllUsers(){
      // Отписываемся от предыдущего слушателя если есть
      database.ref('users').off('value');
      // Устанавливаем слушатель изменений
      database.ref('users').on('value', snap => {
        const users = snap.val() || {};
        // Проверяем изменения аватарок
        Object.keys(users).forEach(uid => {
          const oldUser = allUsers[uid];
          const newUser = users[uid];
          // Если аватарка изменилась, очищаем кэш
          if(oldUser && newUser && oldUser.avatarUrl !== newUser.avatarUrl){
            if(oldUser.avatarUrl) avatarCache.delete(oldUser.avatarUrl);
            if(newUser.avatarUrl) avatarCache.delete(newUser.avatarUrl);
          }
        });
        allUsers = users;
        // Перерисовываем список чатов если он уже загружен
        if(allChats.length > 0){
          renderChatList();
          // Обновляем аватарку в шапке чата если открыт чат с этим пользователем
          if(currentChat && currentChatType === 'private' && currentChatData){
            const chatData = allChats.find(c => c.id === currentChat);
            if(chatData && chatData.avatarUrl){
              const avatarEl = $('chatAvatar');
              loadAvatar(chatData.avatarUrl).then(loadedUrl => {
                if(loadedUrl){
                  avatarEl.innerHTML = `<img src="${loadedUrl}" alt="avatar" style="width:100%;height:100%;object-fit:cover;border-radius:50%;">`;
                }
              }).catch(err => console.error('Error updating chat avatar:', err));
            }
          }
        }
      });
    }
    function updateOnlineStatus(status){
      if(!currentUser) return;
      database.ref(`users/${currentUser.uid}`).update({
        online: status,
        lastSeen: firebase.database.ServerValue.TIMESTAMP
      });
    }
    function setupPresenceOnDisconnect(){
      database.ref(`users/${currentUser.uid}/online`).onDisconnect().set(false);
      database.ref(`users/${currentUser.uid}/lastSeen`).onDisconnect().set(firebase.database.ServerValue.TIMESTAMP);
    }
    // ====== CHAT LIST ======
    function showChatTab(tab){
      currentTab = tab;
      ['all','private','groups','channels'].forEach(t => {
        const el = $('tab' + t.charAt(0).toUpperCase() + t.slice(1));
        el.classList.toggle('bg-violet-600', t === tab);
        el.classList.toggle('text-white', t === tab);
        el.classList.toggle('text-slate-400', t !== tab);
      });
      renderChatList();
    }
    function loadAllChats(){
      // prevent duplicates
      database.ref(`userChats/${currentUser.uid}`).off('value');
      database.ref(`userChats/${currentUser.uid}`).on('value', async snapshot => {
        const chats = snapshot.val() || {};
        const processed = new Set();
        const list = [];
        for(const [chatId, chatData] of Object.entries(chats)){
          if(processed.has(chatId)) continue;
          processed.add(chatId);
          try{
            let chatInfo = { id: chatId, ...chatData, unread:0 };
            // last message
            const msgSnap = await database.ref(`messages/${chatId}`).orderByChild('timestamp').limitToLast(1).once('value');
            const msgs = msgSnap.val();
            if(msgs){
              const lastMsg = Object.values(msgs)[0];
              chatInfo.lastMessage = lastMsg.text || (lastMsg.fileUrl ? '📎 Файл' : '');
              chatInfo.lastTime = lastMsg.timestamp;
              chatInfo.lastSenderId = lastMsg.senderId;
            }
            // unread count
            const unreadSnap = await database.ref(`messages/${chatId}`).orderByChild('timestamp').once('value');
            const allMsgs = unreadSnap.val() || {};
            let unread = 0;
            for(const msg of Object.values(allMsgs)){
              if(msg.senderId !== currentUser.uid && (!msg.readBy || !msg.readBy[currentUser.uid])) unread++;
            }
            chatInfo.unread = unread;
            unreadCounts[chatId] = unread;
            if(chatData.type === 'private'){
              const userData = allUsers[chatData.oderId];
              if(userData){
                chatInfo.name = userData.name;
                chatInfo.email = userData.email;
                chatInfo.online = userData.online;
                chatInfo.avatar = (userData.name || '?').charAt(0).toUpperCase();
                chatInfo.avatarUrl = userData.avatarUrl || null;
              }
            } else if(chatData.type === 'group' || chatData.type === 'channel'){
              try {
                const snap = await database.ref(`${chatData.type}s/${chatId}`).once('value');
                const data = snap.val();
                if(data){
                  chatInfo.name = data.name;
                  chatInfo.avatar = (data.name || '?').charAt(0).toUpperCase();
                  chatInfo.avatarUrl = data.avatarUrl || null;
                  chatInfo.members = data.members;
                  chatInfo.owner = data.owner;
                  chatInfo.description = data.description;
                }
              } catch(err) {
                // Показываем чат с базовой информацией
                chatInfo.name = chatData.name || 'Чат';
                chatInfo.avatar = '?';
              }
            } else {
              // Неизвестный тип - показываем с базовой информацией
              chatInfo.name = chatData.name || 'Чат';
              chatInfo.avatar = '?';
              chatInfo.type = chatData.type || 'unknown';
            }
            if(chatInfo.name) list.push(chatInfo);
          } catch(err){
            // Игнорируем ошибки загрузки чатов
          }
        }
        list.sort((a,b) => (b.lastTime || 0) - (a.lastTime || 0));
        allChats = list;
        renderChatList();
      });
    }
    function renderChatList(){
      const container = $('chatList');
      let filtered = allChats;
      if(currentTab !== 'all'){
        const typeMap = { private:'private', groups:'group', channels:'channel' };
        filtered = allChats.filter(c => c.type === typeMap[currentTab]);
      }
      if(!filtered.length){
        container.innerHTML = '<div class="p-6 text-center text-slate-500">Нет чатов</div>';
        return;
      }
      container.innerHTML = filtered.map(chat => {
        const isActive = currentChat === chat.id;
        const statusDot = (chat.type === 'private' && chat.online) ? 'bg-emerald-500' : 'bg-slate-500';
        const typeIcon = chat.type === 'group' ? '👥' : chat.type === 'channel' ? '📢' : '';
        const unreadBadge = chat.unread > 0 ? `<div class="min-w-[20px] h-5 bg-sky-500 rounded-full text-xs flex items-center justify-center px-1">${chat.unread}</div>` : '';
        const lastMsgPrefix = chat.lastSenderId === currentUser?.uid ? 'Вы: ' : '';
        const gradientClass = chat.type === 'group' ? 'gradient-green' : chat.type === 'channel' ? 'gradient-orange' : 'gradient-bg';
        const titleHtml = chat.type === 'private' ? getNameWithBadge(chat.name, chat.email) : escapeHtml(chat.name);
        // Avatar with image support
        let avatarHtml;
        if(chat.avatarUrl){
          avatarHtml = `<div class="chat-avatar ${gradientClass}" data-avatar-url="${escapeHtml(chat.avatarUrl)}" data-chat-id="${chat.id}"><span>${escapeHtml(chat.avatar || '?')}</span></div>`;
        } else {
          avatarHtml = `<div class="chat-avatar ${gradientClass}">${escapeHtml(chat.avatar || '?')}</div>`;
        }
        return `
          <div class="flex items-center gap-3 p-3 cursor-pointer hover:bg-white/5 transition ${isActive ? 'bg-white/5' : ''}"
               onclick="openChat('${chat.id}','${chat.type}')"
               oncontextmenu="showChatContextMenu(event, '${chat.id}', '${chat.type}'); return false;"
               ontouchstart="startLongPress(event, '${chat.id}', '${chat.type}')"
               ontouchend="cancelLongPress()"
               ontouchmove="cancelLongPress()">
            <div class="relative shrink-0">
              ${avatarHtml}
              ${chat.type === 'private' ? `<div class="absolute bottom-0 right-0 w-3.5 h-3.5 ${statusDot} rounded-full border-2" style="border-color: rgba(15,23,42,.9)"></div>` : ''}
            </div>
            <div class="flex-1 min-w-0">
              <div class="flex justify-between items-center gap-2">
                <div class="font-medium truncate flex items-center gap-2">${typeIcon}<span class="truncate">${titleHtml}</span></div>
                <div class="text-xs text-slate-400 shrink-0">${formatTime(chat.lastTime)}</div>
              </div>
              <div class="flex justify-between items-center gap-2">
                <div class="text-sm text-slate-400 truncate">${escapeHtml(lastMsgPrefix + (chat.lastMessage || 'Нет сообщений'))}</div>
                ${unreadBadge}
              </div>
            </div>
          </div>
        `;
      }).join('');
      // Загружаем аватарки асинхронно
      document.querySelectorAll('[data-avatar-url]').forEach(async (avatarEl) => {
        const avatarUrl = avatarEl.dataset.avatarUrl;
        if(avatarUrl){
          try {
            const loadedUrl = await loadAvatar(avatarUrl);
            if(loadedUrl){
              const span = avatarEl.querySelector('span');
              if(span) span.style.display = 'none';
              avatarEl.innerHTML += `<img src="${loadedUrl}" alt="avatar" style="width:100%;height:100%;object-fit:cover;border-radius:50%;">`;
            }
          } catch(err) {
            console.error('Error loading avatar:', err);
          }
        }
      });
    }
    // Search
    function searchAll(){
      const query = $('searchInput').value.toLowerCase();
      const container = $('searchResults');
      if(!query){
        container.classList.add('hidden');
        container.innerHTML = '';
        return;
      }
      const results = allChats.filter(c => (c.name || '').toLowerCase().includes(query));
      if(!results.length){
        container.innerHTML = '<div class="p-3 text-center text-slate-500">Ничего не найдено</div>';
      } else {
        container.innerHTML = results.map(chat => {
          const gradientClass = chat.type === 'group' ? 'gradient-green' : chat.type === 'channel' ? 'gradient-orange' : 'gradient-bg';
          const title = chat.type === 'private' ? getNameWithBadge(chat.name, chat.email) : escapeHtml(chat.name);
          return `
            <div class="flex items-center gap-3 p-3 hover:bg-white/5 cursor-pointer" onclick="openChat('${chat.id}','${chat.type}'); $('searchInput').value=''; $('searchResults').classList.add('hidden');">
              <div class="w-10 h-10 rounded-full ${gradientClass} grid place-items-center font-bold">${escapeHtml(chat.avatar || '?')}</div>
              <div class="font-medium truncate">${title}</div>
            </div>
          `;
        }).join('');
      }
      container.classList.remove('hidden');
    }
    // ====== LONG PRESS & DELETE CHAT ======
    let longPressTimer = null;
    let longPressChatId = null;
    let longPressChatType = null;
    function startLongPress(event, chatId, chatType){
      longPressChatId = chatId;
      longPressChatType = chatType;
      longPressTimer = setTimeout(() => {
        showChatContextMenu(event, chatId, chatType);
      }, 500); // 500ms для долгого нажатия
    }
    function cancelLongPress(){
      if(longPressTimer){
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
      longPressChatId = null;
      longPressChatType = null;
    }
    async function showChatContextMenu(event, chatId, chatType){
      event.preventDefault();
      event.stopPropagation();
      // Вибрация на мобильных устройствах
      if(navigator.vibrate){
        navigator.vibrate(50);
      }
      const chat = allChats.find(c => c.id === chatId);
      const chatName = chat?.name || 'этот чат';
      // Проверяем, является ли это приватным чатом и является ли текущий пользователь dev
      const isPrivateChat = chatType === 'private';
      const isDev = isDeveloper(currentUserData?.email);
      let otherUserId = null;
      let otherUserData = null;
      let isBanned = false;
      if(isPrivateChat && chat?.oderId){
        otherUserId = chat.oderId;
        otherUserData = allUsers[otherUserId];
        // Проверяем статус бана
        if(otherUserId){
          const banSnap = await database.ref(`bannedUsers/${otherUserId}`).once('value');
          isBanned = banSnap.exists();
        }
      }
      const modal = document.createElement('div');
      modal.id = 'chatContextMenu';
      modal.className = 'modal show';
      modal.onclick = (e) => { if(e.target.id === 'chatContextMenu') modal.remove(); };
      let banButton = '';
      if(isDev && isPrivateChat && otherUserId){
        if(isBanned){
          banButton = `
            <button class="w-full flex items-center gap-3 p-3 hover:bg-white/5 rounded-xl text-green-400" onclick="unbanUser('${otherUserId}', '${escapeHtml(chatName)}')">
              <div class="w-10 h-10 rounded-full grid place-items-center bg-green-500/20">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>
              </div>
              <div class="text-left">
                <div class="font-medium">Разбанить пользователя</div>
                <div class="text-xs text-slate-400">Восстановить доступ</div>
              </div>
            </button>
          `;
        } else {
          banButton = `
            <button class="w-full flex items-center gap-3 p-3 hover:bg-white/5 rounded-xl text-orange-400" onclick="banUser('${otherUserId}', '${escapeHtml(chatName)}')">
              <div class="w-10 h-10 rounded-full grid place-items-center bg-orange-500/20">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18.364 18.364A9 9 0 005.636 5.636m12.728 12.728A9 9 0 015.636 5.636m12.728 12.728L5.636 5.636"/></svg>
              </div>
              <div class="text-left">
                <div class="font-medium">Забанить пользователя</div>
                <div class="text-xs text-slate-400">Заблокировать доступ к чату</div>
              </div>
            </button>
          `;
        }
      }
      modal.innerHTML = `
        <div class="sheet bottom p-4">
          <h3 class="text-lg font-bold mb-2 text-center">${escapeHtml(chatName)}</h3>
          <p class="text-sm text-slate-400 mb-4 text-center">Выберите действие</p>
          <div class="space-y-2">
            ${banButton}
            <button class="w-full flex items-center gap-3 p-3 hover:bg-white/5 rounded-xl text-red-400" onclick="confirmDeleteChat('${chatId}', '${chatType}')">
              <div class="w-10 h-10 rounded-full grid place-items-center bg-red-500/20">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/></svg>
              </div>
              <div class="text-left">
                <div class="font-medium">Удалить чат</div>
                <div class="text-xs text-slate-400">Удалить из списка чатов</div>
              </div>
            </button>
          </div>
          <button class="w-full mt-4 py-2 text-slate-400 hover:text-white" onclick="document.getElementById('chatContextMenu')?.remove()">Отмена</button>
        </div>
      `;
      document.body.appendChild(modal);
    }
    async function confirmDeleteChat(chatId, chatType){
      document.getElementById('chatContextMenu')?.remove();
      const chat = allChats.find(c => c.id === chatId);
      const chatName = chat?.name || 'этот чат';
      const modal = document.createElement('div');
      modal.id = 'deleteConfirmModal';
      modal.className = 'modal show';
      modal.onclick = (e) => { if(e.target.id === 'deleteConfirmModal') modal.remove(); };
      modal.innerHTML = `
        <div class="sheet bottom p-4">
          <h3 class="text-lg font-bold mb-2 text-center text-red-400">Удалить чат?</h3>
          <p class="text-sm text-slate-400 mb-4 text-center">Вы уверены, что хотите удалить "${escapeHtml(chatName)}"?</p>
          <div class="flex gap-2">
            <button class="flex-1 py-3 rounded-xl bg-white/5 hover:bg-white/10" onclick="document.getElementById('deleteConfirmModal')?.remove()">Отмена</button>
            <button class="flex-1 py-3 rounded-xl bg-red-500 hover:bg-red-600 font-medium" onclick="deleteChat('${chatId}', '${chatType}')">Удалить</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
    }
    async function deleteChat(chatId, chatType){
      document.getElementById('deleteConfirmModal')?.remove();
      try {
        showToast('⏳', 'Удаление', 'Удаление чата...');
        // Удаляем чат из userChats текущего пользователя
        await database.ref(`userChats/${currentUser.uid}/${chatId}`).remove();
        // Если это текущий открытый чат, закрываем его
        if(currentChat === chatId){
          currentChat = null;
          currentChatType = null;
          currentChatData = null;
          $('emptyChat').style.display = 'flex';
          $('activeChat').classList.remove('active');
          // На мобильных возвращаемся к списку чатов
          if(window.innerWidth <= 768){
            $('sidebar').style.display = 'flex';
            $('chatArea').style.display = 'none';
          }
        }
        // Обновляем список чатов
        allChats = allChats.filter(c => c.id !== chatId);
        renderChatList();
        showToast('✅', 'Успешно', 'Чат удален');
      } catch(err) {
        console.error('Delete chat error:', err);
        showToast('❌', 'Ошибка', 'Не удалось удалить чат');
      }
    }
    // ====== BAN/UNBAN USERS (DEV ONLY) ======
    async function banUser(userId, userName){
      document.getElementById('chatContextMenu')?.remove();
      const modal = document.createElement('div');
      modal.id = 'banConfirmModal';
      modal.className = 'modal show';
      modal.onclick = (e) => { if(e.target.id === 'banConfirmModal') modal.remove(); };
      modal.innerHTML = `
        <div class="sheet bottom p-4">
          <h3 class="text-lg font-bold mb-2 text-center text-orange-400">Забанить пользователя?</h3>
          <p class="text-sm text-slate-400 mb-3 text-center">Пользователь "${escapeHtml(userName)}" не сможет входить в чат и отправлять сообщения.</p>
          <textarea id="banReason" class="w-full bg-white/5 border border-white/10 rounded-xl px-4 py-2.5 mb-3 outline-none focus:border-violet-500 resize-none" rows="3" placeholder="Причина бана (необязательно)"></textarea>
          <div class="flex gap-2">
            <button class="flex-1 py-3 rounded-xl bg-white/5 hover:bg-white/10" onclick="document.getElementById('banConfirmModal')?.remove()">Отмена</button>
            <button class="flex-1 py-3 rounded-xl bg-orange-500 hover:bg-orange-600 font-medium" onclick="executeBan('${userId}', '${escapeHtml(userName)}')">Забанить</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
    }
    async function executeBan(userId, userName){
      const reason = document.getElementById('banReason')?.value.trim() || 'Забанен администратором';
      document.getElementById('banConfirmModal')?.remove();
      try {
        showToast('⏳', 'Бан', 'Блокировка пользователя...');
        await database.ref(`bannedUsers/${userId}`).set({
          bannedBy: currentUser.uid,
          bannedAt: firebase.database.ServerValue.TIMESTAMP,
          reason: reason
        });
        showToast('✅', 'Успешно', `${userName} забанен`);
      } catch(err) {
        console.error('Ban user error:', err);
        showToast('❌', 'Ошибка', 'Не удалось забанить пользователя');
      }
    }
    async function unbanUser(userId, userName){
      document.getElementById('chatContextMenu')?.remove();
      try {
        showToast('⏳', 'Разбан', 'Разблокировка пользователя...');
        await database.ref(`bannedUsers/${userId}`).remove();
        showToast('✅', 'Успешно', `${userName} разбанен`);
      } catch(err) {
        console.error('Unban user error:', err);
        showToast('❌', 'Ошибка', 'Не удалось разбанить пользователя');
      }
    }
    // ====== OPEN CHAT ======
    async function openChat(chatId, type){
      // Stop previous listeners
      if(currentChat && currentChat !== chatId){
        if(currentChatType === 'saved'){
          database.ref(`savedMessages/${currentUser.uid}`).off();
        } else {
          database.ref(`messages/${currentChat}`).off();
          database.ref(`typing/${currentChat}`).off();
        }
      }
      currentChat = chatId;
      currentChatType = type;
      // Mobile: switch panels
      if(window.innerWidth <= 768){
        $('sidebar').style.display = 'none';
        $('chatArea').style.display = 'flex';
        $('chatArea').classList.add('active');
      } else {
        $('chatArea').style.display = 'flex';
      }
      $('emptyChat').style.display = 'none';
      $('activeChat').classList.add('active');
      closeEmoji();
      if(type === 'private'){
        const chatData = allChats.find(c => c.id === chatId);
        if(chatData){
          currentChatData = chatData;
          const avatarEl = $('chatAvatar');
          // Загружаем аватарку если есть
          if(chatData.avatarUrl){
            try {
              const loadedUrl = await loadAvatar(chatData.avatarUrl);
              if(loadedUrl){
                avatarEl.innerHTML = `<img src="${loadedUrl}" alt="avatar" style="width:100%;height:100%;object-fit:cover;border-radius:50%;">`;
                avatarEl.className = 'chat-avatar chat-avatar-sm gradient-bg';
              } else {
                throw new Error('Failed to load avatar');
              }
            } catch(err) {
              console.error('Error loading avatar:', err);
              avatarEl.innerHTML = '';
              avatarEl.textContent = chatData.avatar || '?';
              avatarEl.className = 'chat-avatar chat-avatar-sm gradient-bg';
            }
          } else {
            avatarEl.innerHTML = '';
            avatarEl.textContent = chatData.avatar || '?';
            avatarEl.className = 'chat-avatar chat-avatar-sm gradient-bg';
          }
          $('chatName').innerHTML = getNameWithBadge(chatData.name, chatData.email);
          database.ref(`users/${chatData.oderId}`).off('value');
          database.ref(`users/${chatData.oderId}`).on('value', snap => {
            const u = snap.val();
            if(u) $('chatStatus').textContent = u.online ? 'В сети' : `Был(а) ${formatLastSeen(u.lastSeen)}`;
          });
        }
        $('chatHeaderActions').innerHTML = '';
      } else {
        const snap = await database.ref(`${type}s/${chatId}`).once('value');
        const data = snap.val();
        currentChatData = data;
        const avatarEl = $('chatAvatar');
        const gradientClass = type === 'group' ? 'gradient-green' : 'gradient-orange';
        if(data?.avatarUrl){
          try {
            const loadedUrl = await loadAvatar(data.avatarUrl);
            if(loadedUrl){
              avatarEl.innerHTML = `<img src="${loadedUrl}" alt="avatar" class="w-full h-full object-cover rounded-full">`;
              avatarEl.className = `chat-avatar chat-avatar-sm ${gradientClass} flex-shrink-0`;
            } else {
              throw new Error('Failed to load avatar');
            }
          } catch(err) {
            console.error('Error loading avatar:', err);
            avatarEl.innerHTML = '';
            avatarEl.textContent = (data?.name || '?').charAt(0).toUpperCase();
            avatarEl.className = `chat-avatar chat-avatar-sm ${gradientClass} flex-shrink-0`;
          }
        } else {
          avatarEl.innerHTML = '';
          avatarEl.textContent = (data?.name || '?').charAt(0).toUpperCase();
          avatarEl.className = `chat-avatar chat-avatar-sm ${gradientClass} flex-shrink-0`;
        }
        $('chatName').textContent = (type === 'group' ? '👥 ' : '📢 ') + (data?.name || '');
        const memberCount = Object.keys(data?.members || {}).length;
        $('chatStatus').textContent = type === 'group' ? `${memberCount} участников` : `${memberCount} подписчиков`;
        const isOwner = data?.owner === currentUser.uid;
        $('chatHeaderActions').innerHTML = isOwner ? `
          <button class="icon-btn" onclick="showSettings('${chatId}','${type}')" title="Настройки">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"/><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/></svg>
          </button>
        ` : '';
      }
      // Channel restrictions
      const isChannel = type === 'channel';
      const isOwner = currentChatData?.owner === currentUser.uid;
      if(isChannel && !isOwner){
        $('messageInputArea').style.display = 'none';
        $('channelNotice').style.display = 'block';
      } else {
        $('messageInputArea').style.display = 'block';
        $('channelNotice').style.display = 'none';
      }
      loadMessages(chatId);
      loadPinnedMessage();
      setupTypingListener(chatId);
      markAsRead(chatId);
      renderChatList();
      requestAnimationFrame(() => {
        $('messagesContainer').scrollTop = $('messagesContainer').scrollHeight;
      });
    }
    // ====== SAVED MESSAGES (ИЗБРАННОЕ) ======
    async function openSavedMessages(){
      // Stop previous listeners
      if(currentChat){
        if(currentChatType === 'saved'){
          database.ref(`savedMessages/${currentUser.uid}`).off();
        } else {
          database.ref(`messages/${currentChat}`).off();
          database.ref(`typing/${currentChat}`).off();
        }
      }
      currentChat = 'saved';
      currentChatType = 'saved';
      currentChatData = null;
      // Mobile: switch panels
      if(window.innerWidth <= 768){
        $('sidebar').style.display = 'none';
        $('chatArea').style.display = 'flex';
        $('chatArea').classList.add('active');
      } else {
        $('chatArea').style.display = 'flex';
      }
      $('emptyChat').style.display = 'none';
      $('activeChat').classList.add('active');
      closeEmoji();
      // Set header
      const avatarEl = $('chatAvatar');
      avatarEl.innerHTML = '<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 5a2 2 0 012-2h10a2 2 0 012 2v16l-7-3.5L5 21V5z"/></svg>';
      avatarEl.className = 'chat-avatar chat-avatar-sm gradient-bg';
      $('chatName').textContent = 'Избранное';
      $('chatStatus').textContent = 'Только вы видите эти сообщения';
      $('chatHeaderActions').innerHTML = '';
      // Show input
      $('messageInputArea').style.display = 'block';
      $('channelNotice').style.display = 'none';
      loadSavedMessages();
      requestAnimationFrame(() => {
        $('messagesContainer').scrollTop = $('messagesContainer').scrollHeight;
      });
    }
    function loadSavedMessages(){
      const container = $('messagesContainer');
      container.innerHTML = '';
      // Отключаем все предыдущие слушатели
      const savedRef = database.ref(`savedMessages/${currentUser.uid}`);
      savedRef.off();
      // Слушаем добавление сообщений
      savedRef.orderByChild('timestamp').on('child_added', snap => {
        const msg = snap.val();
        const msgId = snap.key;
        addMessageToUI(msg, msgId);
      });
      // Слушаем изменения сообщений
      savedRef.on('child_changed', snap => {
        const msg = snap.val();
        const msgId = snap.key;
        console.log('Message changed:', msgId);
        updateMessageUI(msg, msgId);
      });
      // Слушаем удаление сообщений
      savedRef.on('child_removed', snap => {
        const msgId = snap.key;
        console.log('child_removed event fired for:', msgId);
        const msgEl = document.getElementById(`msg-${msgId}`);
        if(msgEl) {
          msgEl.remove();
          console.log('Message element removed from DOM via listener');
        } else {
          console.log('Message element not found in DOM:', msgId);
        }
      });
      console.log('Saved messages listeners attached');
    }
    // ====== MESSAGES ======
    function loadMessages(chatId){
      const container = $('messagesContainer');
      container.innerHTML = '';
      // Отключаем все предыдущие слушатели
      const messagesRef = database.ref(`messages/${chatId}`);
      messagesRef.off();
      // Слушаем добавление сообщений
      messagesRef.orderByChild('timestamp').on('child_added', snap => {
        const msg = snap.val();
        const msgId = snap.key;
        addMessageToUI(msg, msgId);
      });
      // Слушаем изменения сообщений
      messagesRef.on('child_changed', snap => {
        updateMessageUI(snap.val(), snap.key);
      });
      // Слушаем удаление сообщений
      messagesRef.on('child_removed', snap => {
        const msgId = snap.key;
        console.log('child_removed event fired for message:', msgId);
        const msgEl = document.getElementById(`msg-${msgId}`);
        if(msgEl) {
          msgEl.remove();
          console.log('Message element removed from DOM');
        } else {
          console.log('Message element not found:', msgId);
        }
      });
      console.log('Message listeners attached for chat:', chatId);
    }
    function getReadIcon(msg){
      if(msg.readBy && Object.keys(msg.readBy).some(uid => uid !== currentUser.uid)){
        return '<svg class="w-4 h-4 text-sky-300" fill="currentColor" viewBox="0 0 24 24"><path d="M18 7l-1.41-1.41-6.34 6.34 1.41 1.41L18 7zm4.24-1.41L11.66 16.17 7.48 12l-1.41 1.41L11.66 19l12-12-1.42-1.41zM.41 13.41L6 19l1.41-1.41L1.83 12 .41 13.41z"/></svg>';
      }
      return '<svg class="w-4 h-4 text-slate-300" fill="currentColor" viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg>';
    }
    function getReactionsHtml(msgId, msg){
      const reactions = msg.reactions || {};
      const list = Object.entries(reactions).reduce((acc, [emoji, users]) => {
        const count = Object.keys(users||{}).length;
        const hasOwn = !!(users && users[currentUser.uid]);
        if(count > 0) acc.push({emoji, count, hasOwn});
        return acc;
      }, []);
      if(!list.length) return '';
      return `
        <div class="flex flex-wrap gap-1 mt-2">
          ${list.map(r => `
            <button class="px-2 py-0.5 rounded-full text-xs border border-white/10 ${r.hasOwn ? 'bg-violet-600/30' : 'bg-white/5'} hover:bg-white/10" onclick="toggleReaction('${msgId}','${r.emoji}')">
              <span>${r.emoji}</span><span class="ml-1">${r.count}</span>
            </button>
          `).join('')}
        </div>
      `;
    }
    // ====== REPLY (SWIPE TO REPLY) ======
    function setReplyTo(msgId, msg){
      replyToMessageId = msgId;
      replyToMessage = msg || null;
      const preview = $('replyPreview');
      if(!preview) return;
      if(!replyToMessageId){
        preview.classList.remove('show');
        preview.style.display = 'none';
        return;
      }
      const senderName = (allUsers[msg?.senderId]?.name) || msg?.senderName || 'Пользователь';
      const text = (msg?.text && msg.text.trim()) ? msg.text.trim()
        : (msg?.fileName ? '📎 ' + msg.fileName
        : (msg?.fileUrl ? '🖼 Медиа' : 'Сообщение'));
      $('replyAuthor').textContent = senderName;
      $('replyText').textContent = text;
      preview.style.display = 'block';
      preview.classList.add('show');
    }
    function clearReplyTo(){
      replyToMessageId = null;
      replyToMessage = null;
      const preview = $('replyPreview');
      if(preview){
        preview.classList.remove('show');
        preview.style.display = 'none';
      }
    }
    function scrollToMessage(msgId){
      const el = document.getElementById('msg-' + msgId);
      if(!el) return;
      el.scrollIntoView({behavior:'smooth', block:'center'});
      el.classList.add('msg-highlight');
      setTimeout(() => el.classList.remove('msg-highlight'), 1400);
    }
    function attachLongPressToBubble(bubbleEl, msgId, isOwn){
      let pressTimer = null;
      let startX = 0, startY = 0;
      let moved = false;
      // глобальный подавитель "следующего клика", чтобы меню не закрывалось сразу
      window.__suppressClickUntil = window.__suppressClickUntil || 0;
      function clear(){
        if(pressTimer){ clearTimeout(pressTimer); pressTimer = null; }
      }
      function onDocClickCapture(e){
        if(Date.now() < window.__suppressClickUntil){
          e.preventDefault();
          e.stopPropagation();
        }
      }
      // один раз вешаем capture-слушатель
      if(!window.__lpDocCaptureBound){
        window.__lpDocCaptureBound = true;
        document.addEventListener('click', onDocClickCapture, true);
      }
      bubbleEl.addEventListener('touchstart', (e) => {
        if(!e.touches || !e.touches[0]) return;
        moved = false;
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
        clear();
        pressTimer = setTimeout(() => {
          // подавляем клики, которые прилетают после long-press на мобилках
          window.__suppressClickUntil = Date.now() + 600;
          try{ navigator.vibrate && navigator.vibrate(12); }catch(_){}
          const syntheticEvent = {
            preventDefault(){},
            stopPropagation(){},
            target: bubbleEl
          };
          showMessageContextMenu(syntheticEvent, msgId, isOwn);
        }, 420);
      }, {passive:true});
      bubbleEl.addEventListener('touchmove', (e) => {
        if(!pressTimer || !e.touches || !e.touches[0]) return;
        const dx = e.touches[0].clientX - startX;
        const dy = e.touches[0].clientY - startY;
        if(Math.abs(dx) > 10 || Math.abs(dy) > 10){
          moved = true;
          clear();
        }
      }, {passive:true});
      bubbleEl.addEventListener('touchend', () => clear(), {passive:true});
      bubbleEl.addEventListener('touchcancel', () => clear(), {passive:true});
      // На некоторых браузерах long-press всё равно генерирует click — глушим его
      bubbleEl.addEventListener('click', (e) => {
        if(Date.now() < window.__suppressClickUntil){
          e.preventDefault();
          e.stopPropagation();
          return false;
        }
      }, true);
    }
function attachSwipeToBubble(bubbleEl, msgId, msg){
      let startX = 0, startY = 0, active = false, triggered = false;
      let iconEl = null;
      function ensureIcon(){
        if(iconEl) return iconEl;
        // иконка живёт внутри bubble, но позиционируется абсолютно
        bubbleEl.style.position = bubbleEl.style.position || 'relative';
        iconEl = document.createElement('div');
        iconEl.className = 'swipe-reply-icon';
        iconEl.innerHTML = `
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
              d="M3 10h11a4 4 0 014 4v7m0 0l-4-4m4 4l4-4"/>
          </svg>
        `;
        bubbleEl.appendChild(iconEl);
        return iconEl;
      }
      function resetUI(){
        bubbleEl.style.transform = '';
        if(iconEl) iconEl.classList.remove('show');
      }
      bubbleEl.addEventListener('touchstart', (e) => {
        if(!e.touches || !e.touches[0]) return;
        active = true; triggered = false;
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
        ensureIcon();
      }, {passive:true});
      bubbleEl.addEventListener('touchmove', (e) => {
        if(!active || !e.touches || !e.touches[0]) return;
        const dx = e.touches[0].clientX - startX;
        const dy = e.touches[0].clientY - startY;
        // Вертикальный скролл — не вмешиваемся
        if(Math.abs(dy) > 28 && Math.abs(dy) > Math.abs(dx)){
          resetUI();
          return;
        }
        // Только свайп влево
        if(dx >= 0){
          resetUI();
          return;
        }
        const icon = ensureIcon();
        // Двигаем bubble немного влево (как в TG)
        const shift = Math.min(-dx, 88);
        bubbleEl.style.transform = `translateX(-${Math.min(shift, 64)}px)`;
        // Показываем иконку после небольшого порога
        if(shift > 18) icon.classList.add('show');
        else icon.classList.remove('show');
        // Триггер ответа
        if(!triggered && shift > 60 && Math.abs(dy) < 28){
          triggered = true;
          try{ navigator.vibrate && navigator.vibrate(10); }catch(_){}
          setReplyTo(msgId, msg);
          // чуть “отпускаем” bubble обратно
          setTimeout(resetUI, 80);
        }
      }, {passive:true});
      bubbleEl.addEventListener('touchend', () => { active = false; resetUI(); }, {passive:true});
      bubbleEl.addEventListener('touchcancel', () => { active = false; resetUI(); }, {passive:true});
    }
    function addMessageToUI(msg, msgId){
      const container = $('messagesContainer');
      const isOwn = msg.senderId === currentUser.uid;
      // Логируем сообщение для отладки
      if(msg.isVoiceMessage || (msg.fileType && msg.fileType.startsWith('audio/'))){
        console.log('=== ADDING VOICE MESSAGE TO UI ===');
        console.log('Message ID:', msgId);
        console.log('Message object:', JSON.stringify(msg, null, 2));
        console.log('File URL:', msg.fileUrl);
        console.log('File URL type:', typeof msg.fileUrl);
        console.log('File Type:', msg.fileType);
        console.log('Duration:', msg.audioDuration);
        console.log('Is Voice Message:', msg.isVoiceMessage);
      }
      let senderLine = '';
      if(!isOwn && currentChatType !== 'private'){
        const sender = allUsers[msg.senderId];
        senderLine = `<div class="sender-line">${getNameWithBadge(sender?.name || 'Unknown', sender?.email)}</div>`;
      }
      let content = '';
      if(msg.fileUrl){
        if(msg.isVoiceMessage || (msg.fileType && msg.fileType.startsWith('audio/'))){
          // Голосовое сообщение
          const duration = normalizeAudioDuration(msg.audioDuration);
          const safeUrl = escapeHtml(msg.fileUrl);
          console.log('Safe URL for HTML:', safeUrl);
          content += `
            <div class="voice-message" data-audio-url="${safeUrl}" data-audio-type="${escapeHtml(msg.fileType || 'audio/webm')}" data-msg-id="${msgId}">
              <button class="voice-play-btn" onclick="toggleVoicePlayback('${msgId}', '${safeUrl}', '${escapeHtml(msg.fileType || 'audio/webm')}')">
                <svg class="play-icon" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
                <svg class="pause-icon" style="display:none" fill="currentColor" viewBox="0 0 24 24"><path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/></svg>
              </button>
              <div class="voice-waveform" id="waveform-${msgId}">
                ${generateWaveform()}
              </div>
              <span class="voice-duration">${escapeHtml(duration)}</span>
            </div>
          `;
        } else if(msg.fileType && msg.fileType.startsWith('image/')){
          content += `
            <div class="message-media mb-2">
              <img loading="lazy" src="${msg.fileUrl}" alt="image" onclick="viewImage('${msg.fileUrl}')" style="cursor:pointer" data-firebase-image="${msgId}" />
            </div>
          `;
        } else if(msg.fileType && msg.fileType.startsWith('video/')){
          // Проверяем, это кружок или обычное видео
          if(msg.isVideoMessage || msg.isCircle){
            const videoId = 'circle_' + msgId;
            content += `
              <div class="mb-2" style="max-width:240px;position:relative;display:inline-block;">
                <svg id="${videoId}_svg" style="position:absolute;top:0;left:0;width:240px;height:240px;transform:rotate(-90deg);cursor:pointer;" viewBox="0 0 240 240" onclick="seekCircleVideo(event, '${videoId}')">
                  <circle cx="120" cy="120" r="117" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="6"/>
                  <circle id="${videoId}_progress" cx="120" cy="120" r="117" fill="none" stroke="#8b5cf6" stroke-width="6" stroke-dasharray="735" stroke-dashoffset="735" stroke-linecap="round" style="transition:stroke-dashoffset 0.1s linear;"/>
                </svg>
                <video id="${videoId}" src="${msg.fileUrl}" style="border-radius:50%;width:240px;height:240px;object-fit:cover;display:block;cursor:pointer;border:none;background:transparent;" data-firebase-video="${msgId}" onclick="toggleCircleVideo('${videoId}')"></video>
                <div id="${videoId}_play" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:60px;height:60px;background:rgba(0,0,0,0.5);border-radius:50%;display:flex;align-items:center;justify-content:center;pointer-events:none;">
                  <svg style="width:30px;height:30px;margin-left:4px;" fill="white" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
                </div>
              </div>
            `;
          } else {
            content += `
              <div class="message-media mb-2">
                <video controls src="${msg.fileUrl}" data-firebase-video="${msgId}"></video>
              </div>
            `;
          }
        } else {
          // Обычный файл
          const fileUrl = msg.fileUrl;
          const fileName = escapeHtml(msg.fileName || 'Файл');
          if(fileUrl.startsWith('firebase-file://')){
            // Файл в Firebase Database - добавляем кнопку скачивания
            content += `
              <div class="file-chip mb-2" data-file-id="${msgId}">
                <svg class="w-8 h-8 text-violet-300 shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/></svg>
                <div class="min-w-0 flex-1">
                  <div class="text-sm font-medium truncate">${fileName}</div>
                  <div class="text-xs text-slate-400">Нажмите для скачивания</div>
                </div>
                <button onclick="downloadFirebaseFile('${fileUrl}', '${fileName}')" class="icon-btn" style="width:36px;height:36px;" title="Скачать">
                  <svg style="width:18px;height:18px;" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/></svg>
                </button>
              </div>
            `;
          } else {
            // Обычный URL
            content += `
              <a href="${fileUrl}" target="_blank" class="file-chip mb-2">
                <svg class="w-8 h-8 text-violet-300 shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/></svg>
                <div class="min-w-0">
                  <div class="text-sm font-medium truncate">${fileName}</div>
                  <div class="text-xs text-slate-400">Открыть</div>
                </div>
              </a>
            `;
          }
        }
      }
      if(msg.text){
        const captionClass = (msg.fileUrl && msg.fileType && (msg.fileType.startsWith('image/') || msg.fileType.startsWith('video/'))) ? 'msg-text media-caption' : 'msg-text';
        content += `<div class="${captionClass}">${escapeHtml(msg.text)}</div>`;
      }
      const forwardedHtml = msg.forwardedFrom ? `
        <div class="fwd-badge">
          <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 12l1.41 1.41L11 7.83V20h2V7.83l5.59 5.58L20 12l-8-8-8 8z"/></svg>
          <div class="min-w-0">
            <div class="fwd-name">Переслано</div>
            <div class="truncate" style="max-width: 260px;">${escapeHtml(msg.forwardedFrom.senderName || 'Пользователь')}</div>
          </div>
        </div>
      ` : '';
      const replyQuoteHtml = msg.replyTo ? `
        <div class="reply-quote" onclick="scrollToMessage('${escapeHtml(msg.replyTo.id)}')">
          <div class="ra">${escapeHtml(msg.replyTo.senderName || 'Пользователь')}</div>
          <div class="rt">${escapeHtml((msg.replyTo.text || '').toString().slice(0, 80))}${(msg.replyTo.text && msg.replyTo.text.length > 80) ? '…' : ''}</div>
        </div>
      ` : '';
      const reactionsHtml = getReactionsHtml(msgId, msg);
      const editedHtml = msg.edited ? '<span class="edited-indicator">изм.</span>' : '';
      const row = document.createElement('div');
      row.className = `message-row ${isOwn ? 'out' : 'in'} fade-in`;
      row.id = `msg-${msgId}`;
      row.innerHTML = `
        <div class="msg-wrap">
          ${senderLine}
          <div class="bubble-wrap ${isOwn ? 'out' : 'in'}">
            ${isOwn ? `            <button type="button" class="msg-menu-btn" onclick="openMsgMenuBtn(event,'${msgId}', ${isOwn})" title="Меню">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 7h14M5 12h14M5 17h14"/>
              </svg>
            </button>` : ''}
            <div class="bubble ${isOwn ? 'out' : 'in'}${(msg.isCircle||msg.isVideoMessage)?' has-circle':''}" oncontextmenu="return false" onclick="handleMessageTap(event,'${msgId}')">
              ${replyQuoteHtml}
              ${forwardedHtml}
              ${content}
              <div class="meta">
                ${editedHtml}
                <span class="time">${formatTime(msg.timestamp)}</span>
                ${isOwn ? getReadIcon(msg) : ''}
              </div>
              ${reactionsHtml}
            </div>
            ${!isOwn ? `            <button type="button" class="msg-menu-btn" onclick="openMsgMenuBtn(event,'${msgId}', ${isOwn})" title="Меню">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 7h14M5 12h14M5 17h14"/>
              </svg>
            </button>` : ''}
          </div>
        </div>
      `;
      container.appendChild(row);
      const _bubble = row.querySelector('.bubble');
      if(_bubble) attachSwipeToBubble(_bubble, msgId, msg);
      if(_bubble) attachLongPressToBubble(_bubble, msgId, isOwn);
      if(_bubble){
        _bubble.addEventListener('contextmenu', (e) => {
          e.preventDefault();
          showMessageContextMenu(e, msgId, isOwn);
          return false;
        });
      }
      // Загружаем firebase-file:// URLs для изображений
      if(msg.fileUrl && msg.fileUrl.startsWith('firebase-file://') && msg.fileType && msg.fileType.startsWith('image/')){
        const fileId = msg.fileUrl.replace('firebase-file://', '');
        const imgEl = row.querySelector(`[data-firebase-image="${msgId}"]`);
        if(imgEl){
          loadFirebaseFile(fileId).then(base64Data => {
            imgEl.src = base64Data;
          }).catch(err => {
            console.error('Error loading image:', err);
            imgEl.parentElement.innerHTML = '<div style="padding:20px;background:rgba(239,68,68,0.2);border-radius:12px;color:#f87171;text-align:center;">Ошибка загрузки изображения</div>';
          });
        }
      }
      // Загружаем firebase-file:// URLs для видео
      if(msg.fileUrl && msg.fileUrl.startsWith('firebase-file://') && msg.fileType && msg.fileType.startsWith('video/')){
        const fileId = msg.fileUrl.replace('firebase-file://', '');
        const videoEl = row.querySelector(`[data-firebase-video="${msgId}"]`);
        if(videoEl){
          loadFirebaseFile(fileId).then(base64Data => {
            videoEl.src = base64Data;
          }).catch(err => {
            console.error('Error loading video:', err);
            videoEl.parentElement.innerHTML = '<div style="padding:20px;background:rgba(239,68,68,0.2);border-radius:12px;color:#f87171;text-align:center;">Ошибка загрузки видео</div>';
          });
        }
      }
      const nearBottom = container.scrollHeight - container.scrollTop - container.clientHeight < 120;
      if(nearBottom) container.scrollTop = container.scrollHeight;
    }
    function updateMessageUI(msg, msgId){
      const el = document.getElementById(`msg-${msgId}`);
      if(!el) return;
      const bubble = el.querySelector('.bubble');
      if(!bubble) return;
      // Обновляем текст сообщения если он изменился
      const textEl = bubble.querySelector('.msg-text');
      if(textEl && msg.text !== undefined){
        textEl.textContent = msg.text;
      }
      // Обновляем индикатор "изменено"
      const meta = bubble.querySelector('.meta');
      if(meta){
        let editedEl = meta.querySelector('.edited-indicator');
        if(msg.edited && !editedEl){
          meta.insertAdjacentHTML('afterbegin', '<span class="edited-indicator">изм.</span>');
        }
      }
      // Обновляем реакции
      const existing = bubble.querySelector('.flex.flex-wrap');
      const reactionsHtml = getReactionsHtml(msgId, msg);
      if(reactionsHtml){
        if(existing){
          existing.outerHTML = reactionsHtml.trim();
        } else {
          bubble.insertAdjacentHTML('beforeend', reactionsHtml);
        }
      } else {
        if(existing) existing.remove();
      }
      // Обновляем иконку прочтения
      if(meta && msg.senderId === currentUser.uid){
        const icon = meta.querySelector('svg');
        if(icon) icon.outerHTML = getReadIcon(msg);
        else meta.insertAdjacentHTML('beforeend', getReadIcon(msg));
      }
    }
    // ====== REACTIONS ======
    let lastTap = 0;
    function handleMessageTap(e, msgId){
      const now = Date.now();
      if(now - lastTap < 280){
        showReactions(e, msgId);
      }
      lastTap = now;
    }
    // ====== VIDEO CIRCLE PLAYER ======
    function toggleCircleVideo(videoId){
      const video = document.getElementById(videoId);
      const playIcon = document.getElementById(videoId + '_play');
      const progressCircle = document.getElementById(videoId + '_progress');
      if(!video || !playIcon) return;
      if(video.paused){
        video.play();
        playIcon.style.display = 'none';
      } else {
        video.pause();
        playIcon.style.display = 'flex';
      }
      // Обновляем прогресс-бар
      if(progressCircle){
        const circumference = 735; // 2 * PI * 117
        video.ontimeupdate = () => {
          if(video.duration){
            const progress = video.currentTime / video.duration;
            const offset = circumference - (progress * circumference);
            progressCircle.style.strokeDashoffset = offset;
          }
        };
        // Сбрасываем прогресс при окончании
        video.onended = () => {
          playIcon.style.display = 'flex';
          progressCircle.style.strokeDashoffset = circumference;
        };
      } else {
        // Показываем иконку паузы при окончании видео
        video.onended = () => {
          playIcon.style.display = 'flex';
        };
      }
    }
    function seekCircleVideo(event, videoId){
      event.stopPropagation();
      const video = document.getElementById(videoId);
      const svg = document.getElementById(videoId + '_svg');
      if(!video || !svg) return;
      // Получаем координаты клика относительно SVG
      const rect = svg.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      // Вычисляем угол клика относительно центра
      const clickX = event.clientX - centerX;
      const clickY = event.clientY - centerY;
      let angle = Math.atan2(clickY, clickX) * (180 / Math.PI);
      // Корректируем угол (SVG повернут на -90 градусов)
      angle = angle + 90;
      if(angle < 0) angle += 360;
      // Преобразуем угол в процент прогресса
      const progress = angle / 360;
      // Перематываем видео
      if(video.duration){
        video.currentTime = progress * video.duration;
        // Если видео было на паузе, запускаем его
        if(video.paused){
          video.play();
          const playIcon = document.getElementById(videoId + '_play');
          if(playIcon) playIcon.style.display = 'none';
        }
      }
    }
    let messageToDelete = null;
    let currentMessageText = '';
    function openMsgMenuBtn(ev, msgId, isOwn){
  // mini button -> open context menu for конкретного сообщения
  try{ ev.preventDefault(); }catch(e){}
  try{ ev.stopPropagation(); }catch(e){}
  try{ if(ev.stopImmediatePropagation) ev.stopImmediatePropagation(); }catch(e){}
  currentMessageId = msgId;
  showMessageContextMenu(ev, msgId, isOwn);
  return false;
};
async function showMessageContextMenu(e, msgId, isOwn){
      e.preventDefault();
      currentMessageId = msgId;
      const menu = $('messageContextMenu');
      menu.classList.add('show');
// Показываем кнопки редактирования/удаления
      const editBtn = $('editMessageBtn');
      const deleteBtn = $('deleteMessageBtn');
      // Редактировать — только своё
      editBtn.style.display = isOwn ? 'flex' : 'none';
      // Удалять: разрешаем удалять любые сообщения (как вы просили).
      // ВНИМАНИЕ: если Firebase Rules запрещают удаление чужих сообщений,
      // операция может быть отклонена сервером.
      deleteBtn.style.display = 'flex';
      // Проверяем, закреплено ли сообщение
      try{
        const pinnedSnap = await database.ref(`pinnedMessages/${currentChat}`).once('value');
        const pinnedData = pinnedSnap.val();
        const isPinned = pinnedData && pinnedData.messageId === msgId;
        $('pinMessageText').textContent = isPinned ? 'Открепить' : 'Закрепить';
      }catch(err){
        // если pinnedMessages недоступно (например, Избранное) — просто оставим текст по умолчанию
        $('pinMessageText').textContent = 'Закрепить';
      }
      // Определяем путь в зависимости от типа чата
      const messagePath = currentChatType === 'saved'
        ? `savedMessages/${currentUser.uid}/${msgId}`
        : `messages/${currentChat}/${msgId}`;
      // Получаем текст сообщения для копирования
      database.ref(messagePath).once('value', snap => {
        const msg = snap.val();
        currentMessageText = msg?.text || '';
      });
      menu.classList.add('show');
      const rect = (e.currentTarget || e.target).getBoundingClientRect();
const isMobileMenu = window.innerWidth <= 768;
menu.classList.toggle('bottom-sheet', isMobileMenu);
if(isMobileMenu){
  // Bottom-sheet on mobile: always visible inside viewport
  menu.style.left = '10px';
  menu.style.right = '10px';
  menu.style.top = 'auto';
  menu.style.bottom = 'max(12px, env(safe-area-inset-bottom))';
  menu.style.margin = '0 auto';
  menu.style.maxWidth = '520px';
} else {
  // Desktop/tablet: contextual near the bubble, clamped to viewport
  menu.style.right = '';
  menu.style.bottom = '';
  menu.style.margin = '';
  menu.style.maxWidth = '';
  const menuWidth = 200;
  const menuHeight = 260;
  let left = Math.min(rect.left, window.innerWidth - menuWidth - 10);
  left = Math.max(10, left);
  let top = rect.top - menuHeight;
  if(top < 10) top = rect.bottom + 10;
  // Clamp vertically too (in case of very small windows)
  top = Math.min(top, window.innerHeight - menuHeight - 10);
  top = Math.max(10, top);
  menu.style.left = left + 'px';
  menu.style.top = top + 'px';
}
            setTimeout(() => {
        const handler = (ev) => {
          // ignore clicks on menu itself or on the menu button (so it won't instantly close)
          if(menu.contains(ev.target) || ev.target.closest('.msg-menu-btn')) return;
          hideMessageContextMenu();
        };
        document.addEventListener('click', handler, { capture:true, once:true });
      }, 0);}
    function hideMessageContextMenu(){
      $('messageContextMenu').classList.remove('show');
    }
    async function startEditMessage(){
      hideMessageContextMenu();
      if(!currentMessageId || !currentChat) return;
      // Определяем путь в зависимости от типа чата
      const messagePath = currentChatType === 'saved'
        ? `savedMessages/${currentUser.uid}/${currentMessageId}`
        : `messages/${currentChat}/${currentMessageId}`;
      // Получаем текст сообщения
      const snap = await database.ref(messagePath).once('value');
      const msg = snap.val();
      if(!msg || msg.senderId !== currentUser.uid) {
        showToast('❌', 'Ошибка', 'Вы можете редактировать только свои сообщения');
        return;
      }
      $('editMessageText').value = msg.text || '';
      showModal('editMessageModal');
    }
    async function saveEditedMessage(){
      const newText = $('editMessageText').value.trim();
      if(!currentMessageId || !currentChat) {
        closeModal('editMessageModal');
        return;
      }
      try {
        // Определяем путь в зависимости от типа чата
        const messagePath = currentChatType === 'saved'
          ? `savedMessages/${currentUser.uid}/${currentMessageId}`
          : `messages/${currentChat}/${currentMessageId}`;
        await database.ref(messagePath).update({
          text: newText,
          edited: true,
          editedAt: firebase.database.ServerValue.TIMESTAMP
        });
        closeModal('editMessageModal');
        showToast('✅', 'Успешно', 'Сообщение изменено');
      } catch(err) {
        console.error('Edit message error:', err);
        showToast('❌', 'Ошибка', 'Не удалось изменить сообщение');
      }
    }
    async function copyMessage(){
      hideMessageContextMenu();
      if(!currentMessageText) {
        // Определяем путь в зависимости от типа чата
        const messagePath = currentChatType === 'saved'
          ? `savedMessages/${currentUser.uid}/${currentMessageId}`
          : `messages/${currentChat}/${currentMessageId}`;
        // Пробуем получить текст сообщения
        const snap = await database.ref(messagePath).once('value');
        const msg = snap.val();
        currentMessageText = msg?.text || '';
      }
      if(!currentMessageText) {
        showCopyToast('Нечего копировать');
        return;
      }
      try {
        await navigator.clipboard.writeText(currentMessageText);
        showCopyToast('Сообщение скопировано');
      } catch(err) {
        // Fallback для старых браузеров
        const textarea = document.createElement('textarea');
        textarea.value = currentMessageText;
        textarea.style.position = 'fixed';
        textarea.style.opacity = '0';
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand('copy');
        document.body.removeChild(textarea);
        showCopyToast('Сообщение скопировано');
      }
    }
    // ====== PIN MESSAGE ======
    let currentPinnedMessageId = null;
    async function togglePinMessage(){
      hideMessageContextMenu();
      if(!currentMessageId || !currentChat) return;
      // Проверяем, закреплено ли уже это сообщение
      const pinnedSnap = await database.ref(`pinnedMessages/${currentChat}`).once('value');
      const pinnedData = pinnedSnap.val();
      if(pinnedData && pinnedData.messageId === currentMessageId){
        // Открепляем
        await unpinMessage();
      } else {
        // Закрепляем
        await pinMessage();
      }
    }
    async function pinMessage(){
      if(!currentMessageId || !currentChat) return;
      try {
        // Определяем путь в зависимости от типа чата
        const messagePath = currentChatType === 'saved'
          ? `savedMessages/${currentUser.uid}/${currentMessageId}`
          : `messages/${currentChat}/${currentMessageId}`;
        const snap = await database.ref(messagePath).once('value');
        const msg = snap.val();
        if(!msg) return;
        await database.ref(`pinnedMessages/${currentChat}`).set({
          messageId: currentMessageId,
          text: msg.text || '📎 Медиа',
          pinnedBy: currentUser.uid,
          pinnedAt: firebase.database.ServerValue.TIMESTAMP
        });
        showToast('📌', 'Закреплено', 'Сообщение закреплено');
        loadPinnedMessage();
      } catch(err) {
        console.error('Pin message error:', err);
        showToast('❌', 'Ошибка', 'Не удалось закрепить сообщение');
      }
    }
    async function unpinMessage(){
      if(!currentChat) return;
      try {
        await database.ref(`pinnedMessages/${currentChat}`).remove();
        $('pinnedMessage').classList.add('hidden');
        currentPinnedMessageId = null;
        showToast('📌', 'Откреплено', 'Сообщение откреплено');
      } catch(err) {
        console.error('Unpin message error:', err);
        showToast('❌', 'Ошибка', 'Не удалось открепить сообщение');
      }
    }
    async function loadPinnedMessage(){
      if(!currentChat) return;
      database.ref(`pinnedMessages/${currentChat}`).off('value');
      database.ref(`pinnedMessages/${currentChat}`).on('value', snap => {
        const data = snap.val();
        if(data && data.messageId){
          currentPinnedMessageId = data.messageId;
          $('pinnedMessageText').textContent = data.text || 'Сообщение';
          $('pinnedMessage').classList.remove('hidden');
        } else {
          currentPinnedMessageId = null;
          $('pinnedMessage').classList.add('hidden');
        }
      });
    }
    function scrollToPinnedMessage(){
      if(!currentPinnedMessageId) return;
      const msgEl = document.getElementById(`msg-${currentPinnedMessageId}`);
      if(msgEl){
        msgEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
        // Подсвечиваем сообщение
        msgEl.style.backgroundColor = 'rgba(139,92,246,0.2)';
        setTimeout(() => {
          msgEl.style.backgroundColor = '';
        }, 1500);
      }
    }
    function showCopyToast(text){
      // Удаляем предыдущий toast если есть
      const existing = document.querySelector('.copy-toast');
      if(existing) existing.remove();
      const toast = document.createElement('div');
      toast.className = 'copy-toast';
      toast.innerHTML = `
        <svg class="w-5 h-5 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
        </svg>
        ${text}
      `;
      document.body.appendChild(toast);
      setTimeout(() => toast.remove(), 2000);
    }
    async function deleteMessage(){
      hideMessageContextMenu();
      if(!currentMessageId || !currentChat) {
        console.error('Cannot delete: missing currentMessageId or currentChat');
        return;
      }
      // Показываем окно подтверждения
      const modal = document.createElement('div');
      modal.id = 'deleteConfirmModal';
      modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.7);display:flex;align-items:center;justify-content:center;z-index:1000;';
      modal.innerHTML = `
        <div style="background:rgba(15,23,42,0.98);border-radius:20px;padding:24px;max-width:320px;width:90%;border:1px solid rgba(148,163,184,0.18);text-align:center;">
          <div style="width:56px;height:56px;border-radius:50%;background:rgba(239,68,68,0.15);display:flex;align-items:center;justify-content:center;margin:0 auto 16px;">
            <svg style="width:28px;height:28px;color:#f87171;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
            </svg>
          </div>
          <div style="font-size:17px;font-weight:600;margin-bottom:8px;">Удалить сообщение?</div>
          <div style="font-size:14px;color:#9ca3af;margin-bottom:20px;">Это действие нельзя отменить</div>
          <div style="display:flex;gap:8px;">
            <button id="cancelDeleteBtn" style="flex:1;padding:12px;border:none;border-radius:12px;background:rgba(148,163,184,0.1);color:#9ca3af;font-size:15px;font-weight:500;cursor:pointer;">Отмена</button>
            <button id="confirmDeleteBtn" style="flex:1;padding:12px;border:none;border-radius:12px;background:#ef4444;color:white;font-size:15px;font-weight:500;cursor:pointer;">Удалить</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      // Обработчик отмены
      modal.querySelector('#cancelDeleteBtn').onclick = () => {
        modal.remove();
      };
      // Обработчик подтверждения
      modal.querySelector('#confirmDeleteBtn').onclick = async () => {
        const msgIdToDelete = currentMessageId;
        const chatIdToDelete = currentChat;
        const chatTypeToDelete = currentChatType;
        modal.remove();
        try {
          // Определяем путь
          let path;
          if(chatTypeToDelete === 'saved'){
            path = `savedMessages/${currentUser.uid}/${msgIdToDelete}`;
          } else {
            path = `messages/${chatIdToDelete}/${msgIdToDelete}`;
          }
          console.log('Deleting message at path:', path);
          // Удаляем из Firebase
          await database.ref(path).remove();
          console.log('Message deleted from Firebase');
          // Удаляем из DOM
          const msgElement = document.getElementById(`msg-${msgIdToDelete}`);
          if(msgElement){
            msgElement.remove();
            console.log('Message removed from DOM');
          }
          // Показываем уведомление
          const toast = document.createElement('div');
          toast.style.cssText = 'position:fixed;bottom:80px;left:50%;transform:translateX(-50%);background:rgba(15,23,42,0.95);color:white;padding:12px 24px;border-radius:12px;font-size:14px;z-index:1000;display:flex;align-items:center;gap:8px;';
          toast.innerHTML = '<svg style="width:20px;height:20px;color:#10b981;" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/></svg>Сообщение удалено';
          document.body.appendChild(toast);
          setTimeout(() => toast.remove(), 2000);
        } catch(error) {
          console.error('Error deleting message:', error);
          // Показываем ошибку
          const errorToast = document.createElement('div');
          errorToast.style.cssText = 'position:fixed;bottom:80px;left:50%;transform:translateX(-50%);background:rgba(239,68,68,0.95);color:white;padding:12px 24px;border-radius:12px;font-size:14px;z-index:1000;';
          errorToast.textContent = 'Ошибка удаления: ' + error.message;
          document.body.appendChild(errorToast);
          setTimeout(() => errorToast.remove(), 3000);
        }
      };
      // Закрытие по клику вне модального окна
      modal.onclick = (e) => {
        if(e.target === modal) modal.remove();
      };
    }
    function closeConfirmModal(){
      const modal = document.getElementById('deleteConfirmModal');
      if(modal) modal.remove();
    }
    async function confirmDeleteMessage(){
      // Эта функция больше не используется, но оставляем для совместимости
      closeConfirmModal();
    }
    // Старая функция для совместимости
    function showReactions(e, msgId){
      // Определяем, своё ли это сообщение
      const msgEl = document.getElementById(`msg-${msgId}`);
      const isOwn = msgEl && msgEl.classList.contains('out');
      showMessageContextMenu(e, msgId, isOwn);
    }
    function hideReactions(){
      hideMessageContextMenu();
    }
    function addReaction(emoji){
      if(!currentMessageId || !currentChat) return;
      const basePath = (currentChatType === 'saved') ? `savedMessages/${currentUser.uid}` : `messages/${currentChat}`;
      database.ref(`${basePath}/${currentMessageId}/reactions/${emoji}/${currentUser.uid}`).set(true);
      hideReactions();
    }
    function toggleReaction(msgId, emoji){
      const basePath = (currentChatType === 'saved') ? `savedMessages/${currentUser.uid}` : `messages/${currentChat}`;
      database.ref(`${basePath}/${msgId}/reactions/${emoji}/${currentUser.uid}`).once('value', snap => {
        if(snap.exists()) snap.ref.remove();
        else snap.ref.set(true);
      });
    }
    // ====== TYPING ======
    function handleTyping(){
      if(!currentChat) return;
      database.ref(`typing/${currentChat}/${currentUser.uid}`).set(true);
      clearTimeout(typingTimeout);
      typingTimeout = setTimeout(() => {
        database.ref(`typing/${currentChat}/${currentUser.uid}`).set(false);
      }, 1800);
    }
    function setupTypingListener(chatId){
      database.ref(`typing/${chatId}`).off();
      database.ref(`typing/${chatId}`).on('value', snap => {
        const map = snap.val() || {};
        const typers = Object.entries(map).filter(([uid, val]) => uid !== currentUser.uid && val);
        if(typers.length){
          $('typingText').textContent = currentChatType === 'private' ? 'печатает...' : 'печатают...';
          $('typingIndicator').classList.remove('hidden');
        } else {
          $('typingIndicator').classList.add('hidden');
        }
      });
    }
    // ====== READ ======
    function markAsRead(chatId){
      database.ref(`messages/${chatId}`).once('value', snap => {
        const msgs = snap.val() || {};
        for(const [msgId, msg] of Object.entries(msgs)){
          if(msg.senderId !== currentUser.uid){
            database.ref(`messages/${chatId}/${msgId}/readBy/${currentUser.uid}`).set(true);
          }
        }
      });
      // Сбросить счётчик непрочитанных
      unreadCounts[chatId] = 0;
      // Обновить данные в allChats
      const chatIndex = allChats.findIndex(c => c.id === chatId);
      if(chatIndex !== -1){
        allChats[chatIndex].unread = 0;
      }
      // Перерисовать список чатов, чтобы убрать бейдж
      renderChatList();
    }
    // ====== FILES ======
    function handleFileSelect(event){
      const file = event.target.files?.[0];
      if(!file) return;
      pendingFile = file;
      $('uploadPreview').classList.remove('hidden');
      const previewImage = $('uploadPreviewImage');
      const previewFile = $('uploadPreviewFile');
      if(file.type.startsWith('image/')){
        previewImage.classList.remove('hidden');
        previewFile.classList.add('hidden');
        previewImage.src = URL.createObjectURL(file);
      } else {
        previewImage.classList.add('hidden');
        previewFile.classList.remove('hidden');
        previewFile.style.display = 'flex';
        $('uploadFileName').textContent = file.name;
      }
      $('imageCaption').value = '';
      event.target.value = '';
    }
    function cancelUpload(){
      if(uploadTask){
        try{ uploadTask.cancel(); }catch(e){}
        uploadTask = null;
      }
      isUploading = false;
      pendingFile = null;
      $('uploadPreview').classList.add('hidden');
      $('uploadProgress').classList.add('hidden');
      $('uploadProgressBar').style.width = '0%';
      $('imageCaption').value = '';
      const img = $('uploadPreviewImage');
      if(img && img.src && img.src.startsWith('blob:')){
        try{ URL.revokeObjectURL(img.src); }catch(e){}
      }
    }
    async function uploadImageToImgBB(file){
      return new Promise((resolve, reject) => {
        const formData = new FormData();
        formData.append('image', file);
        formData.append('key', IMGBB_API_KEY);
        $('uploadProgress').classList.remove('hidden');
        $('uploadProgressBar').style.width = '0%';
        const xhr = new XMLHttpRequest();
        xhr.open('POST', 'https://api.imgbb.com/1/upload');
        xhr.upload.onprogress = (e) => {
          if(e.lengthComputable){
            const p = (e.loaded / e.total) * 100;
            $('uploadProgressBar').style.width = p + '%';
          }
        };
        xhr.onload = () => {
          try{
            const data = JSON.parse(xhr.responseText);
            if(xhr.status === 200 && data.success){
              resolve(data.data.url);
            } else {
              reject(new Error(data?.error?.message || 'imgBB upload failed'));
            }
          } catch(err){
            reject(new Error('Failed to parse imgBB response'));
          }
        };
        xhr.onerror = () => reject(new Error('Network error'));
        xhr.send(formData);
      });
    }
    async function uploadFileToFirebase(file){
      console.log('📤 Uploading file to Firebase Database:', file.name, file.type);
      try {
        // Проверяем размер (Firebase Database имеет лимит ~10MB для base64)
        const maxSize = 10 * 1024 * 1024; // 10MB
        if(file.size > maxSize){
          throw new Error(`Файл слишком большой (${(file.size / 1024 / 1024).toFixed(1)}MB). Максимум 10MB для загрузки в Firebase Database.`);
        }
        // Конвертируем в base64
        const reader = new FileReader();
        const base64Promise = new Promise((resolve, reject) => {
          reader.onload = () => resolve(reader.result);
          reader.onerror = reject;
          reader.readAsDataURL(file);
        });
        const base64Data = await base64Promise;
        // Сохраняем в Firebase Database
        const fileRef = database.ref('files').push();
        const fileId = fileRef.key;
        await fileRef.set({
          data: base64Data,
          mimeType: file.type,
          fileName: file.name,
          uploadedBy: currentUser.uid,
          uploadedAt: firebase.database.ServerValue.TIMESTAMP
        });
        // Возвращаем firebase-file:// URL
        const url = `firebase-file://${fileId}`;
        console.log('✅ File uploaded to Firebase Database:', url);
        return url;
      } catch(err) {
        console.error('❌ Upload failed:', err);
        throw new Error('Не удалось загрузить файл: ' + err.message);
      }
    }
    async function uploadFile(file){
      // Все файлы загружаем в Firebase Database
      return await uploadFileToFirebase(file);
    }
    async function sendFileWithCaption(){
      if(!pendingFile || !currentChat) return;
      if(isUploading) return showToast('⏳','Подождите','Загрузка файла в процессе...');
      // Проверяем бан
      const banSnap = await database.ref(`bannedUsers/${currentUser.uid}`).once('value');
      if(banSnap.exists()){
        showToast('🚫', 'Доступ запрещен', 'Вы заблокированы и не можете отправлять файлы');
        await auth.signOut();
        return;
      }
      isUploading = true;
      const caption = $('imageCaption').value.trim();
      let messageData = {
        senderId: currentUser.uid,
        timestamp: firebase.database.ServerValue.TIMESTAMP,
        readBy: { [currentUser.uid]: true }
      };
      if(caption) messageData.text = caption;
      // reply support for files
      if(replyToMessageId){
        const senderName = (allUsers[replyToMessage?.senderId]?.name) || replyToMessage?.senderName || 'Пользователь';
        const replyText = (replyToMessage?.text && replyToMessage.text.trim()) ? replyToMessage.text.trim()
          : (replyToMessage?.fileName ? '📎 ' + replyToMessage.fileName
          : (replyToMessage?.fileUrl ? '🖼 Медиа' : 'Сообщение'));
        messageData.replyTo = {
          id: replyToMessageId,
          senderId: replyToMessage?.senderId || null,
          senderName,
          text: replyText
        };
      }
      try{
        $('uploadProgress').classList.remove('hidden');
        $('uploadProgressBar').style.width = '50%';
        const url = await uploadFile(pendingFile);
        $('uploadProgressBar').style.width = '100%';
        messageData.fileUrl = url;
        messageData.fileName = pendingFile.name;
        messageData.fileType = pendingFile.type;
        // Сохраняем в избранное или обычный чат
        if(currentChatType === 'saved'){
          await database.ref(`savedMessages/${currentUser.uid}`).push(messageData);
        } else {
          await database.ref(`messages/${currentChat}`).push(messageData);
          await touchChatUpdatedAt(currentChat);
        }
        showToast('✅','Успешно','Файл отправлен');
      } catch(err){
        console.error(err);
        showToast('❌','Ошибка', 'Не удалось загрузить файл');
      } finally {
        isUploading = false;
        $('uploadProgress').classList.add('hidden');
        cancelUpload();
        clearReplyTo();
      }
    }
    async function touchChatUpdatedAt(chatId){
      await database.ref(`userChats/${currentUser.uid}/${chatId}/updatedAt`).set(firebase.database.ServerValue.TIMESTAMP);
      if(currentChatType === 'private'){
        const chatData = allChats.find(c => c.id === chatId);
        if(chatData) await database.ref(`userChats/${chatData.oderId}/${chatId}/updatedAt`).set(firebase.database.ServerValue.TIMESTAMP);
      } else if(currentChatData?.members){
        const ids = Object.keys(currentChatData.members);
        await Promise.all(ids.filter(uid => uid !== currentUser.uid).map(uid => database.ref(`userChats/${uid}/${chatId}/updatedAt`).set(firebase.database.ServerValue.TIMESTAMP)));
      }
    }
    // ====== SEND MESSAGE ======
    async function sendMessage(e){
      e.preventDefault();
      if(isUploading) return showToast('⏳','Подождите','Загрузка файла в процессе...');
      if(pendingFile) return sendFileWithCaption();
      // Проверяем бан
      const banSnap = await database.ref(`bannedUsers/${currentUser.uid}`).once('value');
      if(banSnap.exists()){
        showToast('🚫', 'Доступ запрещен', 'Вы заблокированы и не можете отправлять сообщения');
        await auth.signOut();
        return;
      }
      const input = $('messageInput');
      const text = input.value.trim();
      if(!text || !currentChat) return;
      input.value = '';
      if(typingTimeout){
        clearTimeout(typingTimeout);
        if(currentChatType !== 'saved'){
          database.ref(`typing/${currentChat}/${currentUser.uid}`).set(false);
        }
      }
      const messageData = {
        senderId: currentUser.uid,
        timestamp: firebase.database.ServerValue.TIMESTAMP,
        readBy: { [currentUser.uid]: true },
        text
      };
      // ====== REPLY SUPPORT ======
      if(replyToMessageId){
        const senderName = (allUsers[replyToMessage?.senderId]?.name) || replyToMessage?.senderName || 'Пользователь';
        const replyText = (replyToMessage?.text && replyToMessage.text.trim()) ? replyToMessage.text.trim()
          : (replyToMessage?.fileName ? '📎 ' + replyToMessage.fileName
          : (replyToMessage?.fileUrl ? '🖼 Медиа' : 'Сообщение'));
        messageData.replyTo = {
          id: replyToMessageId,
          senderId: replyToMessage?.senderId || null,
          senderName,
          text: replyText
        };
      }
      // Сохраняем в избранное или обычный чат
      if(currentChatType === 'saved'){
        await database.ref(`savedMessages/${currentUser.uid}`).push(messageData);
      } else {
        await database.ref(`messages/${currentChat}`).push(messageData);
        await touchChatUpdatedAt(currentChat);
      }
      // clear reply after send
      if(replyToMessageId) clearReplyTo();
      closeEmoji();
    }
    // ====== IMAGE VIEWER ======
    function viewImage(url){
      $('viewerImage').src = url;
      $('imageViewer').classList.add('show');
    }
    function closeImageViewer(){
      $('imageViewer').classList.remove('show');
      $('viewerImage').src = '';
    }
    // ====== FILE PICKER MENU ======
    function openFilePicker(){
      const wrap = document.createElement('div');
      wrap.id = 'filePickerModal';
      wrap.className = 'modal show';
      wrap.onclick = (e) => { if(e.target && e.target.id === 'filePickerModal') wrap.remove(); };
      wrap.innerHTML = `
        <div class="sheet bottom p-4">
          <h3 class="text-lg font-bold mb-4 text-center">Прикрепить</h3>
          <div class="space-y-2">
            <button class="w-full flex items-center gap-3 p-3 hover:bg-white/5 rounded-xl" onclick="selectFileType('photo')">
              <div class="w-10 h-10 rounded-full grid place-items-center" style="background: linear-gradient(135deg,#3b82f6,#22d3ee)">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/></svg>
              </div>
              <div class="text-left">
                <div class="font-medium">Фото или Видео</div>
                <div class="text-xs text-slate-400">Фото через imgBB (до 32MB)</div>
              </div>
            </button>
            <button class="w-full flex items-center gap-3 p-3 hover:bg-white/5 rounded-xl" onclick="selectFileType('camera')">
              <div class="w-10 h-10 rounded-full grid place-items-center" style="background: linear-gradient(135deg,#22c55e,#34d399)">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 0110.07 4h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0018.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z"/><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 13a3 3 0 11-6 0 3 3 0 016 0z"/></svg>
              </div>
              <div class="text-left">
                <div class="font-medium">Камера</div>
                <div class="text-xs text-slate-400">Сделать фото</div>
              </div>
            </button>
            <button class="w-full flex items-center gap-3 p-3 hover:bg-white/5 rounded-xl" onclick="selectFileType('document')">
              <div class="w-10 h-10 rounded-full grid place-items-center" style="background: linear-gradient(135deg,#fb923c,#fbbf24)">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/></svg>
              </div>
              <div class="text-left">
                <div class="font-medium">Документ</div>
                <div class="text-xs text-slate-400">PDF, Word, Excel</div>
              </div>
            </button>
          </div>
          <button class="w-full mt-4 py-2 text-slate-400 hover:text-white" onclick="document.getElementById('filePickerModal')?.remove()">Отмена</button>
        </div>
      `;
      document.body.appendChild(wrap);
    }
    function selectFileType(type){
      const input = $('fileInput');
      if(type === 'camera'){
        input.accept = 'image/*';
        input.capture = 'environment';
      } else if(type === 'photo'){
        input.accept = 'image/*,video/*';
        input.removeAttribute('capture');
      } else {
        input.accept = '.pdf,.doc,.docx,.xls,.xlsx,.ppt,.pptx,.txt,.zip,.rar';
        input.removeAttribute('capture');
      }
      input.click();
      document.getElementById('filePickerModal')?.remove();
    }
    // ====== EMOJI PICKER ======
    let currentEmojiCategory = 'smileys';
    function toggleEmoji(){
      const picker = $('emojiPicker');
      const willShow = !picker.classList.contains('show');
      picker.classList.toggle('show');
      if(willShow){
        renderEmojiCategory(currentEmojiCategory);
      }
    }
    function closeEmoji(){
      $('emojiPicker').classList.remove('show');
    }
    function showEmojiCategory(cat){
      currentEmojiCategory = cat;
      ['smileys','gestures','animals','food','activities','travel','objects','symbols'].forEach(k => {
        const btn = $('emojiTab' + k.charAt(0).toUpperCase() + k.slice(1));
        btn.classList.toggle('active', k === cat);
      });
      renderEmojiCategory(cat);
    }
    function renderEmojiCategory(cat){
      const grid = $('emojiGrid');
      const list = EMOJI[cat] || [];
      grid.innerHTML = list.map(e => `<button type="button" class="emoji-btn" onclick="addEmoji('${e.replace(/'/g, "\\'")}')">${e}</button>`).join('');
    }
    function addEmoji(emoji){
      const input = $('messageInput');
      input.value += emoji;
      input.focus();
    }
    // ====== NOTIFICATIONS ======
    function requestNotificationPermission() {
      if ('Notification' in window) {
        if (Notification.permission === 'default') {
          Notification.requestPermission().then(permission => {
            console.log('Notification permission:', permission);
          });
        }
      }
    }
    function setupNotificationListener(){
      database.ref(`userChats/${currentUser.uid}`).off('child_changed');
      database.ref(`userChats/${currentUser.uid}`).on('child_changed', async snap => {
        const chatId = snap.key;
        if(chatId === currentChat && document.visibilityState === 'visible') return;
        const msgSnap = await database.ref(`messages/${chatId}`).orderByChild('timestamp').limitToLast(1).once('value');
        const msgs = msgSnap.val();
        if(!msgs) return;
        const lastMsg = Object.values(msgs)[0];
        if(lastMsg.senderId === currentUser.uid) return;
        const senderName = allUsers[lastMsg.senderId]?.name || 'Новое сообщение';
        const msgText = lastMsg.text || (lastMsg.fileUrl ? '📎 Файл' : '');
        // Воспроизводим звук уведомления
        playNotificationSound();
        // Показываем внутреннее уведомление (toast)
        showToast(senderName.charAt(0).toUpperCase(), senderName, msgText, chatId);
        // Показываем системное push-уведомление если страница не активна
        if(Notification.permission === 'granted' && document.visibilityState !== 'visible'){
          try {
            const notification = new Notification(senderName, {
              body: msgText,
              icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23667eea"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H6l-2 2V4h16v12z"/></svg>',
              tag: chatId, // Группируем уведомления по чату
              renotify: true,
              silent: true // Мы играем свой звук
            });
            // При клике на уведомление открываем чат
            notification.onclick = () => {
              window.focus();
              const chat = allChats.find(c => c.id === chatId);
              if(chat) openChat(chatId, chat.type);
              notification.close();
            };
            // Автоматически закрываем через 5 секунд
            setTimeout(() => notification.close(), 5000);
          } catch(e) {
            console.warn('Notification error:', e);
          }
        }
      });
    }
    // ====== CREATE / USERS ======
    function showCreateMenu(){ showModal('createMenuModal'); }
    function showNewPrivateChat(){
      closeModal('createMenuModal');
      $('userSearchInput').value = '';
      $('userSearchResults').innerHTML = '';
      renderUsersForChat();
      showModal('newPrivateChatModal');
    }
    function renderUsersForChat(){
      const container = $('userSearchResults');
      const users = Object.entries(allUsers).filter(([uid]) => uid !== currentUser.uid);
      const unique = new Map(users);
      const arr = Array.from(unique.entries());
      if(!arr.length){
        container.innerHTML = '<div class="p-4 text-center text-slate-500">Нет пользователей</div>';
        return;
      }
      container.innerHTML = arr.map(([uid, user]) => `
        <div class="flex items-center gap-3 p-3 hover:bg-white/5 cursor-pointer rounded-xl" onclick="startPrivateChat('${uid}')" data-uid="${uid}">
          <div class="w-10 h-10 rounded-full gradient-bg grid place-items-center font-bold">${escapeHtml((user?.name || '?').charAt(0).toUpperCase())}</div>
          <div class="min-w-0">
            <div class="font-medium truncate">${getNameWithBadge(user?.name || 'Unknown', user?.email)}</div>
            <div class="text-xs text-slate-400">${user?.online ? 'В сети' : 'Не в сети'}</div>
          </div>
        </div>
      `).join('');
    }
    function searchUsersForChat(){
      const q = $('userSearchInput').value.toLowerCase();
      document.querySelectorAll('#userSearchResults [data-uid]').forEach(item => {
        const name = item.querySelector('.font-medium')?.textContent.toLowerCase() || '';
        item.style.display = name.includes(q) ? '' : 'none';
      });
    }
    async function startPrivateChat(otherUserId){
      closeModal('newPrivateChatModal');
      const chatId = currentUser.uid < otherUserId ? `${currentUser.uid}_${otherUserId}` : `${otherUserId}_${currentUser.uid}`;
      await database.ref(`userChats/${currentUser.uid}/${chatId}`).set({
        type: 'private',
        oderId: otherUserId,
        updatedAt: firebase.database.ServerValue.TIMESTAMP
      });
      await database.ref(`userChats/${otherUserId}/${chatId}`).set({
        type: 'private',
        oderId: currentUser.uid,
        updatedAt: firebase.database.ServerValue.TIMESTAMP
      });
      setTimeout(() => openChat(chatId, 'private'), 150);
    }
    // ====== SEARCH GROUPS/CHANNELS ======
    let currentSearchTab = 'groups';
    function showSearchGroupsChannels(){
      closeModal('createMenuModal');
      currentSearchTab = 'groups';
      $('groupChannelSearchInput').value = '';
      switchSearchTab('groups');
      showModal('searchGroupsChannelsModal');
      loadAllGroupsChannels();
    }
    function switchSearchTab(tab){
      currentSearchTab = tab;
      $('searchTabGroups').className = tab === 'groups' ? 'flex-1 py-2 px-3 rounded-lg text-sm font-medium bg-violet-600 text-white' : 'flex-1 py-2 px-3 rounded-lg text-sm font-medium text-slate-400';
      $('searchTabChannels').className = tab === 'channels' ? 'flex-1 py-2 px-3 rounded-lg text-sm font-medium bg-violet-600 text-white' : 'flex-1 py-2 px-3 rounded-lg text-sm font-medium text-slate-400';
      searchGroupsChannels();
    }
    async function loadAllGroupsChannels(){
      searchGroupsChannels();
    }
    async function searchGroupsChannels(){
      const query = $('groupChannelSearchInput').value.toLowerCase();
      const container = $('groupChannelSearchResults');
      try {
        const type = currentSearchTab === 'groups' ? 'groups' : 'channels';
        const snapshot = await database.ref(type).once('value');
        const data = snapshot.val();
        if(!data){
          container.innerHTML = `<div class="p-4 text-center text-slate-500">Нет ${currentSearchTab === 'groups' ? 'групп' : 'каналов'}</div>`;
          return;
        }
        let results = Object.entries(data).map(([id, item]) => ({id, ...item}));
        // Фильтруем по поисковому запросу
        if(query){
          results = results.filter(item =>
            (item.name || '').toLowerCase().includes(query) ||
            (item.description || '').toLowerCase().includes(query)
          );
        }
        if(!results.length){
          container.innerHTML = '<div class="p-4 text-center text-slate-500">Ничего не найдено</div>';
          return;
        }
        const gradientClass = currentSearchTab === 'groups' ? 'gradient-green' : 'gradient-orange';
        const icon = currentSearchTab === 'groups' ? '👥' : '📢';
        container.innerHTML = results.map(item => {
          const memberCount = Object.keys(item.members || {}).length;
          const isMember = item.members && item.members[currentUser.uid];
          return `
            <div class="flex items-center gap-3 p-3 hover:bg-white/5 rounded-xl">
              <div class="w-12 h-12 rounded-full ${gradientClass} grid place-items-center font-bold text-lg shrink-0">
                ${escapeHtml((item.name || '?').charAt(0).toUpperCase())}
              </div>
              <div class="flex-1 min-w-0">
                <div class="font-medium truncate flex items-center gap-2">
                  <span>${icon}</span>
                  <span>${escapeHtml(item.name || 'Без названия')}</span>
                </div>
                <div class="text-sm text-slate-400 truncate">${escapeHtml(item.description || 'Нет описания')}</div>
                <div class="text-xs text-slate-500">${memberCount} ${memberCount === 1 ? 'участник' : memberCount < 5 ? 'участника' : 'участников'}</div>
              </div>
              ${isMember
                ? '<button class="px-4 py-2 rounded-lg bg-white/5 text-slate-400 text-sm" disabled>Вы участник</button>'
                : `<button class="px-4 py-2 rounded-lg bg-violet-600 hover:bg-violet-700 text-sm font-medium" onclick="joinGroupChannel('${item.id}', '${currentSearchTab}')">Вступить</button>`
              }
            </div>
          `;
        }).join('');
      } catch(err) {
        console.error('Search error:', err);
        container.innerHTML = '<div class="p-4 text-center text-red-400">Ошибка загрузки</div>';
      }
    }
    async function joinGroupChannel(id, type){
      try {
        showToast('⏳', 'Вступление', 'Присоединение...');
        const snapshot = await database.ref(`${type}/${id}`).once('value');
        const data = snapshot.val();
        if(!data){
          showToast('❌', 'Ошибка', 'Группа/канал не найдены');
          return;
        }
        // Добавляем пользователя в участники
        await database.ref(`${type}/${id}/members/${currentUser.uid}`).set(true);
        // Добавляем чат в список пользователя
        await database.ref(`userChats/${currentUser.uid}/${id}`).set({
          type: type === 'groups' ? 'group' : 'channel',
          updatedAt: firebase.database.ServerValue.TIMESTAMP
        });
        showToast('✅', 'Успешно', `Вы вступили в ${type === 'groups' ? 'группу' : 'канал'}`);
        closeModal('searchGroupsChannelsModal');
        // Обновляем список чатов
        setTimeout(() => {
          loadAllChats();
        }, 500);
      } catch(err) {
        console.error('Join error:', err);
        showToast('❌', 'Ошибка', 'Не удалось вступить');
      }
    }
    function showCreateGroup(){
      closeModal('createMenuModal');
      $('groupName').value = '';
      $('groupSearchInput').value = '';
      selectedGroupMembers = [];
      renderSelectedMembers();
      renderUsersForGroup();
      showModal('createGroupModal');
    }
    function renderUsersForGroup(){
      const container = $('groupSearchResults');
      const users = Object.entries(allUsers).filter(([uid]) => uid !== currentUser.uid);
      const unique = new Map(users);
      const arr = Array.from(unique.entries());
      if(!arr.length){
        container.innerHTML = '<div class="p-4 text-center text-slate-500">Нет пользователей</div>';
        return;
      }
      container.innerHTML = arr.map(([uid, user]) => {
        const selected = selectedGroupMembers.includes(uid);
        return `
          <div class="flex items-center gap-3 p-3 hover:bg-white/5 cursor-pointer rounded-xl ${selected ? 'bg-violet-600/15' : ''}" onclick="toggleGroupMember('${uid}')" data-uid="${uid}">
            <div class="w-10 h-10 rounded-full gradient-bg grid place-items-center font-bold">${escapeHtml((user?.name || '?').charAt(0).toUpperCase())}</div>
            <div class="flex-1 min-w-0">
              <div class="font-medium truncate">${getNameWithBadge(user?.name || 'Unknown', user?.email)}</div>
            </div>
            ${selected ? '<svg class="w-5 h-5 text-violet-300" fill="currentColor" viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg>' : ''}
          </div>
        `;
      }).join('');
    }
    function searchUsersForGroup(){
      const q = $('groupSearchInput').value.toLowerCase();
      document.querySelectorAll('#groupSearchResults [data-uid]').forEach(item => {
        const name = item.querySelector('.font-medium')?.textContent.toLowerCase() || '';
        item.style.display = name.includes(q) ? '' : 'none';
      });
    }
    function toggleGroupMember(uid){
      const i = selectedGroupMembers.indexOf(uid);
      if(i >= 0) selectedGroupMembers.splice(i,1);
      else selectedGroupMembers.push(uid);
      renderSelectedMembers();
      renderUsersForGroup();
    }
    function renderSelectedMembers(){
      const container = $('selectedMembers');
      if(!selectedGroupMembers.length){
        container.innerHTML = '';
        return;
      }
      container.innerHTML = selectedGroupMembers.map(uid => {
        const u = allUsers[uid];
        return `
          <div class="flex items-center gap-1 bg-violet-600/20 border border-white/10 rounded-full px-2 py-1">
            <span class="text-sm">${escapeHtml(u?.name || 'User')}</span>
            <button class="text-slate-300 hover:text-white" onclick="toggleGroupMember('${uid}')">
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
            </button>
          </div>
        `;
      }).join('');
    }
    async function createGroup(){
      const name = $('groupName').value.trim();
      if(!name) return showToast('⚠️','Ошибка','Введите название группы');
      if(!selectedGroupMembers.length) return showToast('⚠️','Ошибка','Добавьте участников');
      try{
        const groupId = database.ref().child('groups').push().key;
        const members = { [currentUser.uid]: true };
        selectedGroupMembers.forEach(uid => members[uid] = true);
        const updates = {};
        updates[`groups/${groupId}`] = {
          name,
          owner: currentUser.uid,
          members,
          createdAt: firebase.database.ServerValue.TIMESTAMP
        };
        Object.keys(members).forEach(uid => {
          updates[`userChats/${uid}/${groupId}`] = { type:'group', updatedAt: firebase.database.ServerValue.TIMESTAMP };
        });
        await database.ref().update(updates);
        closeModal('createGroupModal');
        selectedGroupMembers = [];
        showToast('✅','Успешно','Группа создана');
        setTimeout(() => openChat(groupId,'group'), 150);
      } catch(err){
        console.error(err);
        showToast('❌','Ошибка', err.message || 'Не удалось создать группу');
      }
    }
    function showCreateChannel(){
      closeModal('createMenuModal');
      $('channelName').value = '';
      $('channelDescription').value = '';
      showModal('createChannelModal');
    }
    async function createChannel(){
      const name = $('channelName').value.trim();
      const description = $('channelDescription').value.trim();
      if(!name) return showToast('⚠️','Ошибка','Введите название канала');
      try{
        const channelId = database.ref().child('channels').push().key;
        const updates = {};
        updates[`channels/${channelId}`] = {
          name,
          description,
          owner: currentUser.uid,
          members: { [currentUser.uid]: true },
          createdAt: firebase.database.ServerValue.TIMESTAMP
        };
        updates[`userChats/${currentUser.uid}/${channelId}`] = { type:'channel', updatedAt: firebase.database.ServerValue.TIMESTAMP };
        await database.ref().update(updates);
        closeModal('createChannelModal');
        showToast('✅','Успешно','Канал создан');
        setTimeout(() => openChat(channelId,'channel'), 150);
      } catch(err){
        console.error(err);
        showToast('❌','Ошибка', err.message || 'Не удалось создать канал');
      }
    }
    // ====== ACCOUNT SWITCHER ======
    function showAccountSwitcher(){
      const accounts = JSON.parse(localStorage.getItem('flashchat_accounts') || '[]');
      const container = $('accountSwitcherList');
      container.innerHTML = accounts.map(acc => {
        const isCurrent = currentUser?.email === acc.email;
        return `
          <div class="flex items-center gap-3 p-3 rounded-xl border border-white/10 ${isCurrent ? 'bg-violet-600/15' : 'hover:bg-white/5 cursor-pointer'}" ${isCurrent ? '' : `onclick=\"switchAccount('${escapeHtml(acc.email)}','${escapeHtml(acc.password)}')\"`}>
            <div class="w-10 h-10 gradient-bg rounded-full grid place-items-center font-bold">${escapeHtml((acc.name||'?').charAt(0).toUpperCase())}</div>
            <div class="flex-1 min-w-0">
              <div class="font-medium truncate">${escapeHtml(acc.name || acc.email)}</div>
              <div class="text-xs text-slate-400 truncate">${escapeHtml(acc.email)}</div>
            </div>
            ${isCurrent ? '<span class="text-xs text-violet-300">Текущий</span>' : ''}
          </div>
        `;
      }).join('') || '<div class="p-4 text-center text-slate-500">Нет сохранённых аккаунтов</div>';
      showModal('accountSwitcherModal');
    }
    async function switchAccount(email, password){
      closeModal('accountSwitcherModal');
      // Очищаем данные текущего пользователя
      clearAllData();
      // Выходим и входим в новый аккаунт
      await auth.signOut();
      await auth.signInWithEmailAndPassword(email, password);
    }
    function addNewAccount(){
      closeModal('accountSwitcherModal');
      // Очищаем данные
      clearAllData();
      auth.signOut();
    }
    // ====== PROFILE ======
    async function showProfile(){
      const snap = await database.ref(`users/${currentUser.uid}`).once('value');
      const user = snap.val() || {};
      // Обновляем аватарку
      const avatarLetter = $('profileAvatarLetter');
      const avatarImg = $('profileAvatarImg');
      if(user.avatarUrl){
        // Загружаем аватарку
        try {
          const loadedUrl = await loadAvatar(user.avatarUrl);
          if(loadedUrl){
            avatarImg.src = loadedUrl;
            avatarImg.classList.remove('hidden');
            avatarLetter.style.display = 'none';
          } else {
            throw new Error('Failed to load avatar');
          }
        } catch(err) {
          console.error('Error loading avatar:', err);
          // Показываем букву если не удалось загрузить
          avatarImg.classList.add('hidden');
          avatarLetter.style.display = '';
          avatarLetter.textContent = (user.name || '?').charAt(0).toUpperCase();
        }
      } else {
        avatarImg.classList.add('hidden');
        avatarLetter.style.display = '';
        avatarLetter.textContent = (user.name || '?').charAt(0).toUpperCase();
      }
      $('profileNameDisplay').innerHTML = getNameWithBadge(user.name || 'User', currentUser.email);
      $('profileEmail').textContent = currentUser.email;
      $('newProfileName').value = user.name || '';
      $('newProfileStatus').value = user.status || '';
      showModal('profileModal');
    }
    async function handleProfileAvatarSelect(e){
      const file = e.target.files[0];
      if(!file) return;
      if(!file.type.startsWith('image/')){
        showToast('❌', 'Ошибка', 'Выберите изображение');
        return;
      }
      try {
        showToast('⏳', 'Загрузка', 'Загрузка аватарки...');
        // Конвертируем в base64
        const reader = new FileReader();
        const base64Promise = new Promise((resolve, reject) => {
          reader.onload = () => resolve(reader.result);
          reader.onerror = reject;
          reader.readAsDataURL(file);
        });
        const base64Data = await base64Promise;
        // Сохраняем в Firebase Database
        const fileRef = database.ref('files').push();
        const fileId = fileRef.key;
        await fileRef.set({
          data: base64Data,
          mimeType: file.type,
          uploadedBy: currentUser.uid,
          uploadedAt: firebase.database.ServerValue.TIMESTAMP
        });
        const avatarUrl = `firebase-file://${fileId}`;
        // Обновляем профиль
        await database.ref(`users/${currentUser.uid}`).update({ avatarUrl });
        // Обновляем UI
        const avatarImg = $('profileAvatarImg');
        const avatarLetter = $('profileAvatarLetter');
        avatarImg.src = base64Data;
        avatarImg.classList.remove('hidden');
        avatarLetter.style.display = 'none';
        showToast('✅', 'Успешно', 'Аватарка обновлена');
        // Обновляем список чатов
        await loadAllUsers();
        renderChatList();
      } catch(err){
        console.error('Avatar upload error:', err);
        showToast('❌', 'Ошибка', 'Не удалось загрузить аватарку');
      }
    }
    async function updateProfile(e){
      e.preventDefault();
      const name = $('newProfileName').value.trim();
      const status = $('newProfileStatus').value.trim();
      if(!name) return;
      await database.ref(`users/${currentUser.uid}`).update({ name, status, nameLower: name.toLowerCase() });
      showToast('✓','Успешно','Профиль обновлен');
      closeModal('profileModal');
      let accounts = JSON.parse(localStorage.getItem('flashchat_accounts') || '[]');
      accounts = accounts.map(a => a.email === currentUser.email ? { ...a, name } : a);
      localStorage.setItem('flashchat_accounts', JSON.stringify(accounts));
      loadSavedAccounts();
      await loadAllUsers();
      renderChatList();
    }
    // ====== APP SETTINGS ======
    let testMicStream = null;
    let testCameraStream = null;
    let micTestAnimationFrame = null;
    async function showAppSettings(){
      // Загружаем устройства
      await loadMediaDevices();
      // Загружаем настройки
      const settings = JSON.parse(localStorage.getItem('flashchat_settings') || '{}');
      // Устанавливаем тему
      const theme = settings.theme || 'dark';
      document.querySelectorAll('.theme-btn').forEach(btn => btn.classList.remove('active'));
      $(`theme${theme.charAt(0).toUpperCase() + theme.slice(1)}`).classList.add('active');
      // Уведомления
      $('soundNotifications').checked = settings.soundNotifications !== false;
      $('desktopNotifications').checked = settings.desktopNotifications === true;
      showModal('appSettingsModal');
    }
    async function loadMediaDevices(){
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const microphones = devices.filter(d => d.kind === 'audioinput');
        const cameras = devices.filter(d => d.kind === 'videoinput');
        const settings = JSON.parse(localStorage.getItem('flashchat_settings') || '{}');
        // Микрофоны
        const micSelect = $('microphoneSelect');
        micSelect.innerHTML = '<option value="">По умолчанию</option>';
        microphones.forEach(mic => {
          const option = document.createElement('option');
          option.value = mic.deviceId;
          option.textContent = mic.label || `Микрофон ${microphones.indexOf(mic) + 1}`;
          if(mic.deviceId === settings.microphoneId){
            option.selected = true;
          }
          micSelect.appendChild(option);
        });
        // Камеры
        const camSelect = $('cameraSelect');
        camSelect.innerHTML = '<option value="">По умолчанию</option>';
        cameras.forEach(cam => {
          const option = document.createElement('option');
          option.value = cam.deviceId;
          option.textContent = cam.label || `Камера ${cameras.indexOf(cam) + 1}`;
          if(cam.deviceId === settings.cameraId){
            option.selected = true;
          }
          camSelect.appendChild(option);
        });
      } catch(err){
        console.error('Error loading devices:', err);
      }
    }
    function setTheme(theme){
      const settings = JSON.parse(localStorage.getItem('flashchat_settings') || '{}');
      settings.theme = theme;
      localStorage.setItem('flashchat_settings', JSON.stringify(settings));
      document.querySelectorAll('.theme-btn').forEach(btn => btn.classList.remove('active'));
      $(`theme${theme.charAt(0).toUpperCase() + theme.slice(1)}`).classList.add('active');
      applyTheme(theme);
      showToast('✅', 'Успешно', 'Тема изменена');
    }
    function applyTheme(theme){
      if(theme === 'auto'){
        const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        theme = isDark ? 'dark' : 'light';
      }
      if(theme === 'light'){
        document.body.classList.add('light-theme');
      } else {
        document.body.classList.remove('light-theme');
      }
    }
    function saveMicrophonePreference(){
      const settings = JSON.parse(localStorage.getItem('flashchat_settings') || '{}');
      settings.microphoneId = $('microphoneSelect').value;
      localStorage.setItem('flashchat_settings', JSON.stringify(settings));
      showToast('✅', 'Сохранено', 'Микрофон выбран');
    }
    function saveCameraPreference(){
      const settings = JSON.parse(localStorage.getItem('flashchat_settings') || '{}');
      settings.cameraId = $('cameraSelect').value;
      localStorage.setItem('flashchat_settings', JSON.stringify(settings));
      showToast('✅', 'Сохранено', 'Камера выбрана');
    }
    function saveNotificationSettings(){
      const settings = JSON.parse(localStorage.getItem('flashchat_settings') || '{}');
      settings.soundNotifications = $('soundNotifications').checked;
      settings.desktopNotifications = $('desktopNotifications').checked;
      localStorage.setItem('flashchat_settings', JSON.stringify(settings));
      if(settings.desktopNotifications && Notification.permission === 'default'){
        Notification.requestPermission();
      }
    }
    async function testMicrophone(){
      try {
        const settings = JSON.parse(localStorage.getItem('flashchat_settings') || '{}');
        const constraints = {
          audio: settings.microphoneId ? { deviceId: { exact: settings.microphoneId } } : true
        };
        testMicStream = await navigator.mediaDevices.getUserMedia(constraints);
        showModal('micTestModal');
        // Анализируем уровень звука
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const analyser = audioContext.createAnalyser();
        const microphone = audioContext.createMediaStreamSource(testMicStream);
        const dataArray = new Uint8Array(analyser.frequencyBinCount);
        microphone.connect(analyser);
        analyser.fftSize = 256;
        const updateLevel = () => {
          analyser.getByteFrequencyData(dataArray);
          const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
          const level = Math.min(100, (average / 128) * 100);
          $('micTestBar').style.width = level + '%';
          if(level > 50){
            $('micTestStatus').textContent = 'Отлично! Микрофон работает';
            $('micTestIcon').style.transform = 'scale(1.1)';
          } else if(level > 20){
            $('micTestStatus').textContent = 'Хорошо, продолжайте говорить';
            $('micTestIcon').style.transform = 'scale(1.05)';
          } else {
            $('micTestStatus').textContent = 'Говорите в микрофон...';
            $('micTestIcon').style.transform = 'scale(1)';
          }
          micTestAnimationFrame = requestAnimationFrame(updateLevel);
        };
        updateLevel();
      } catch(err){
        console.error('Mic test error:', err);
        showToast('❌', 'Ошибка', 'Не удалось получить доступ к микрофону');
      }
    }
    function stopMicTest(){
      if(testMicStream){
        testMicStream.getTracks().forEach(track => track.stop());
        testMicStream = null;
      }
      if(micTestAnimationFrame){
        cancelAnimationFrame(micTestAnimationFrame);
        micTestAnimationFrame = null;
      }
      closeModal('micTestModal');
    }
    async function testCamera(){
      try {
        const settings = JSON.parse(localStorage.getItem('flashchat_settings') || '{}');
        const constraints = {
          video: settings.cameraId ? { deviceId: { exact: settings.cameraId } } : true
        };
        testCameraStream = await navigator.mediaDevices.getUserMedia(constraints);
        showModal('cameraTestModal');
        $('cameraTestVideo').srcObject = testCameraStream;
      } catch(err){
        console.error('Camera test error:', err);
        showToast('❌', 'Ошибка', 'Не удалось получить доступ к камере');
      }
    }
    function stopCameraTest(){
      if(testCameraStream){
        testCameraStream.getTracks().forEach(track => track.stop());
        testCameraStream = null;
      }
      $('cameraTestVideo').srcObject = null;
      closeModal('cameraTestModal');
    }
    // ====== SETTINGS (OWNER) ======
    async function showSettings(chatId, type){
      const snap = await database.ref(`${type}s/${chatId}`).once('value');
      const data = snap.val();
      if(!data || data.owner !== currentUser.uid){
        return showToast('❌','Ошибка','У вас нет прав для редактирования');
      }
      $('settingsModal').dataset.chatId = chatId;
      $('settingsModal').dataset.type = type;
      pendingAvatarFile = null;
      $('settingsTitle').textContent = type === 'group' ? 'Настройки группы' : 'Настройки канала';
      $('settingsName').value = data.name || '';
      $('settingsDescription').value = data.description || '';
      $('deleteButtonText').textContent = type === 'group' ? 'Удалить группу' : 'Удалить канал';
      // Avatar
      const avatarLetter = $('settingsAvatarLetter');
      const avatarImg = $('settingsAvatarImg');
      const avatarContainer = $('settingsAvatar');
      avatarContainer.className = `chat-avatar chat-avatar-lg ${type === 'group' ? 'gradient-green' : 'gradient-orange'} cursor-pointer`;
      if(data.avatarUrl){
        avatarLetter.classList.add('hidden');
        avatarImg.classList.remove('hidden');
        avatarImg.src = data.avatarUrl;
      } else {
        avatarLetter.classList.remove('hidden');
        avatarImg.classList.add('hidden');
        avatarLetter.textContent = (data.name || '?').charAt(0).toUpperCase();
      }
      $('settingsDescriptionBlock').style.display = type === 'channel' ? 'block' : 'none';
      const members = data.members || {};
      $('settingsMemberCount').textContent = Object.keys(members).length;
      const list = $('settingsMembersList');
      list.innerHTML = '';
      for(const uid of Object.keys(members)){
        const u = allUsers[uid];
        if(!u) continue;
        const isOwner = uid === data.owner;
        const isSelf = uid === currentUser.uid;
        list.innerHTML += `
          <div class="flex items-center gap-3 p-2 bg-white/5 border border-white/10 rounded-xl">
            <div class="w-8 h-8 rounded-full gradient-bg grid place-items-center font-bold text-sm">${escapeHtml((u.name || '?').charAt(0).toUpperCase())}</div>
            <div class="flex-1 min-w-0">
              <div class="font-medium text-sm truncate">${getNameWithBadge(u.name || 'Unknown', u.email)} ${isOwner ? '<span class="text-xs text-violet-300">(владелец)</span>' : ''}</div>
            </div>
            ${(!isSelf && !isOwner) ? `
              <button class="icon-btn" style="width:36px;height:36px" onclick="removeMember('${chatId}','${type}','${uid}')" title="Удалить">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
              </button>
            ` : ''}
          </div>
        `;
      }
      showModal('settingsModal');
    }
    function handleAvatarSelect(event){
      const file = event.target.files?.[0];
      if(!file) return;
      if(!file.type.startsWith('image/')){
        showToast('⚠️','Ошибка','Выберите изображение');
        return;
      }
      pendingAvatarFile = file;
      // Preview
      const reader = new FileReader();
      reader.onload = (e) => {
        $('settingsAvatarLetter').classList.add('hidden');
        $('settingsAvatarImg').classList.remove('hidden');
        $('settingsAvatarImg').src = e.target.result;
      };
      reader.readAsDataURL(file);
      event.target.value = '';
    }
    async function uploadAvatarToImgBB(file){
      return new Promise((resolve, reject) => {
        const formData = new FormData();
        formData.append('image', file);
        formData.append('key', IMGBB_API_KEY);
        const xhr = new XMLHttpRequest();
        xhr.open('POST', 'https://api.imgbb.com/1/upload');
        xhr.onload = () => {
          try{
            const data = JSON.parse(xhr.responseText);
            if(xhr.status === 200 && data.success){
              resolve(data.data.url);
            } else {
              reject(new Error(data?.error?.message || 'Upload failed'));
            }
          } catch(err){
            reject(new Error('Failed to parse response'));
          }
        };
        xhr.onerror = () => reject(new Error('Network error'));
        xhr.send(formData);
      });
    }
    async function saveSettings(){
      const chatId = $('settingsModal').dataset.chatId;
      const type = $('settingsModal').dataset.type;
      const name = $('settingsName').value.trim();
      const description = $('settingsDescription').value.trim();
      if(!name) return showToast('⚠️','Ошибка','Введите название');
      const updates = { name };
      if(type === 'channel') updates.description = description;
      try{
        // Upload avatar if changed
        if(pendingAvatarFile){
          showToast('⏳','Загрузка','Загружаем аватарку...');
          const avatarUrl = await uploadAvatarToImgBB(pendingAvatarFile);
          updates.avatarUrl = avatarUrl;
          pendingAvatarFile = null;
        }
        await database.ref(`${type}s/${chatId}`).update(updates);
        showToast('✅','Успешно','Настройки сохранены');
        closeModal('settingsModal');
        // Refresh current chat header if open
        if(currentChat === chatId){
          openChat(chatId, type);
        }
        await loadAllUsers();
        loadAllChats();
      } catch(err){
        console.error(err);
        showToast('❌','Ошибка', err.message || 'Не удалось сохранить');
      }
    }
    async function removeMember(chatId, type, uid){
      if(!confirm('Удалить участника?')) return;
      try{
        await database.ref(`${type}s/${chatId}/members/${uid}`).remove();
        await database.ref(`userChats/${uid}/${chatId}`).remove();
        showToast('✅','Успешно','Участник удален');
        showSettings(chatId, type);
      } catch(err){
        console.error(err);
        showToast('❌','Ошибка', err.message || 'Не удалось удалить');
      }
    }
    async function deleteGroupOrChannel(){
      const chatId = $('settingsModal').dataset.chatId;
      const type = $('settingsModal').dataset.type;
      const typeName = type === 'group' ? 'группу' : 'канал';
      if(!confirm(`Вы уверены, что хотите удалить ${typeName}? Это действие нельзя отменить.`)) return;
      try{
        const snap = await database.ref(`${type}s/${chatId}/members`).once('value');
        const members = snap.val() || {};
        const updates = {};
        Object.keys(members).forEach(uid => {
          updates[`userChats/${uid}/${chatId}`] = null;
        });
        updates[`messages/${chatId}`] = null;
        updates[`${type}s/${chatId}`] = null;
        await database.ref().update(updates);
        closeModal('settingsModal');
        closeChat();
        showToast('✅','Успешно', type === 'group' ? 'Группа удалена' : 'Канал удален');
      } catch(err){
        console.error(err);
        showToast('❌','Ошибка', err.message || 'Не удалось удалить');
      }
    }
    // ====== GLOBAL EVENTS ======
    document.addEventListener('visibilitychange', () => {
      if(currentUser) updateOnlineStatus(!document.hidden);
      if(!document.hidden && currentChat) markAsRead(currentChat);
    });
    window.addEventListener('resize', () => {
      if(!$('chatScreen').classList.contains('active')) return;
      if(window.innerWidth <= 768){
        if(currentChat){
          $('sidebar').style.display = 'none';
          $('chatArea').style.display = 'flex';
          $('chatArea').classList.add('active');
        } else {
          $('sidebar').style.display = 'flex';
          $('chatArea').style.display = 'none';
          $('chatArea').classList.remove('active');
        }
      } else {
        $('sidebar').style.display = 'flex';
        $('chatArea').style.display = 'flex';
        $('chatArea').classList.remove('active');
      }
    });
    document.addEventListener('keydown', (e) => {
      if(e.key === 'Escape'){
        ['createMenuModal','newPrivateChatModal','createGroupModal','createChannelModal','accountSwitcherModal','profileModal','appSettingsModal','settingsModal','editMessageModal','micTestModal','cameraTestModal'].forEach(id => closeModal(id));
        closeImageViewer();
        closeConfirmModal();
        hideMessageContextMenu();
        closeEmoji();
        // Останавливаем тесты устройств
        stopMicTest();
        stopCameraTest();
      }
    });
    // Закрытие confirmModal по клику на фон
    $('confirmModal').addEventListener('click', (e) => {
      if(e.target.id === 'confirmModal') closeConfirmModal();
    });
    // Close emoji picker on outside click (Telegram-like)
    document.addEventListener('click', (e) => {
      const picker = $('emojiPicker');
      if(!picker.classList.contains('show')) return;
      const inputArea = $('messageInputArea');
      if(inputArea && inputArea.contains(e.target)) return;
      closeEmoji();
    });
    // ====== VOICE MESSAGES ======
    // Функция для загрузки файлов из Firebase Database
    async function loadFirebaseFile(fileId) {
      try {
        const fileSnapshot = await database.ref(`files/${fileId}`).once('value');
        const fileData = fileSnapshot.val();
        if (!fileData || !fileData.data) {
          throw new Error('File not found');
        }
        return fileData.data; // Возвращаем base64 data URL
      } catch(err) {
        console.error('Error loading firebase file:', err);
        throw err;
      }
    }
    // Кэш для аватарок
    const avatarCache = new Map();
    // Функция для загрузки и кэширования аватарок
    async function loadAvatar(avatarUrl) {
      if(!avatarUrl) return null;
      // Проверяем кэш
      if(avatarCache.has(avatarUrl)){
        return avatarCache.get(avatarUrl);
      }
      // Если это firebase-file:// URL
      if(avatarUrl.startsWith('firebase-file://')){
        try {
          const fileId = avatarUrl.replace('firebase-file://', '');
          const base64Data = await loadFirebaseFile(fileId);
          avatarCache.set(avatarUrl, base64Data);
          return base64Data;
        } catch(err) {
          console.error('Error loading avatar:', err);
          return null;
        }
      }
      // Обычный URL
      avatarCache.set(avatarUrl, avatarUrl);
      return avatarUrl;
    }
    // Функция для скачивания файлов из Firebase Database
    async function downloadFirebaseFile(fileUrl, fileName) {
      try {
        showToast('⏳', 'Загрузка', 'Скачивание файла...');
        const fileId = fileUrl.replace('firebase-file://', '');
        const base64Data = await loadFirebaseFile(fileId);
        // Создаём ссылку для скачивания
        const link = document.createElement('a');
        link.href = base64Data;
        link.download = fileName;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        showToast('✅', 'Успешно', 'Файл скачан');
      } catch(err) {
        console.error('Error downloading file:', err);
        showToast('❌', 'Ошибка', 'Не удалось скачать файл');
      }
    }
    function generateWaveform(){
      // Генерируем случайную волновую форму (40 полосок)
      const bars = [];
      for(let i = 0; i < 40; i++){
        const height = Math.random() * 20 + 8;
        bars.push(`<div class="voice-bar" style="height:${height}px"></div>`);
      }
      return bars.join('');
    }
    async function toggleVoicePlayback(msgId, audioUrl, mimeType){
      const voiceMsg = document.querySelector(`[data-msg-id="${msgId}"]`);
      if(!voiceMsg) {
        console.error('Voice message element not found:', msgId);
        return;
      }
      const playBtn = voiceMsg.querySelector('.voice-play-btn');
      const playIcon = playBtn.querySelector('.play-icon');
      const pauseIcon = playBtn.querySelector('.pause-icon');
      const waveform = voiceMsg.querySelector('.voice-waveform');
      const bars = waveform.querySelectorAll('.voice-bar');
      // Если играет другое аудио - останавливаем его
      if(currentPlayingAudio && currentPlayingAudio.msgId !== msgId){
        stopCurrentAudio();
      }
      // Если это аудио уже играет - ставим на паузу
      if(currentPlayingAudio && currentPlayingAudio.msgId === msgId){
        currentPlayingAudio.audio.pause();
        playIcon.style.display = 'block';
        pauseIcon.style.display = 'none';
        bars.forEach(bar => bar.classList.remove('active'));
        currentPlayingAudio = null;
        return;
      }
      console.log('Playing voice message:', msgId, audioUrl);
      // Проверяем URL
      if(!audioUrl || audioUrl === 'undefined' || audioUrl === 'null'){
        console.error('Invalid audio URL:', audioUrl);
        showToast('❌', 'Ошибка', 'Неверный URL аудио файла');
        return;
      }
      try {
        // Если это firebase-file:// URL, загружаем из Firebase Database
        let actualAudioUrl = audioUrl;
        if(audioUrl.startsWith('firebase-file://')){
          const fileId = audioUrl.replace('firebase-file://', '');
          console.log('Loading firebase file:', fileId);
          actualAudioUrl = await loadFirebaseFile(fileId);
        }
        // Создаём элемент audio
        const audio = document.createElement('audio');
        audio.preload = 'auto';
        audio.volume = 1.0;
        audio.controls = false;
        audio.src = actualAudioUrl;
        currentPlayingAudio = { audio, msgId, bars };
        // Показываем иконку паузы
        playIcon.style.display = 'none';
        pauseIcon.style.display = 'block';
        // Анимация волновой формы
        let currentBar = 0;
        const animateWaveform = () => {
          if(!currentPlayingAudio || currentPlayingAudio.msgId !== msgId) return;
          bars.forEach((bar, i) => {
            bar.classList.toggle('active', i === currentBar);
          });
          currentBar = (currentBar + 1) % bars.length;
          if(!audio.paused){
            setTimeout(animateWaveform, 50);
          }
        };
        audio.onplay = () => {
          animateWaveform();
        };
        audio.onended = () => {
          playIcon.style.display = 'block';
          pauseIcon.style.display = 'none';
          bars.forEach(bar => bar.classList.remove('active'));
          currentPlayingAudio = null;
        };
        audio.onerror = (e) => {
          console.error('Audio playback error:', audio.error);
          let errorMsg = 'Не удалось воспроизвести аудио';
          if(audio.error){
            switch(audio.error.code){
              case 1: errorMsg = 'Загрузка прервана'; break;
              case 2: errorMsg = 'Ошибка сети'; break;
              case 3: errorMsg = 'Ошибка декодирования'; break;
              case 4: errorMsg = 'Формат не поддерживается'; break;
            }
          }
          showToast('❌', 'Ошибка', errorMsg);
          playIcon.style.display = 'block';
          pauseIcon.style.display = 'none';
          bars.forEach(bar => bar.classList.remove('active'));
          currentPlayingAudio = null;
        };
        // Пробуем воспроизвести
        const playPromise = audio.play();
        if(playPromise !== undefined) {
          playPromise.catch(err => {
            console.error('Playback failed:', err);
            playIcon.style.display = 'block';
            pauseIcon.style.display = 'none';
            currentPlayingAudio = null;
            if(err.name === 'NotAllowedError'){
              showToast('⚠️', 'Внимание', 'Нажмите на кнопку еще раз');
            } else {
              showToast('❌', 'Ошибка', 'Не удалось воспроизвести аудио');
            }
          });
        }
      } catch(err) {
        console.error('Error in toggleVoicePlayback:', err);
        showToast('❌', 'Ошибка', 'Не удалось загрузить аудио файл');
        playIcon.style.display = 'block';
        pauseIcon.style.display = 'none';
      }
    }
    function stopCurrentAudio(){
      if(!currentPlayingAudio) return;
      const { audio, msgId, bars } = currentPlayingAudio;
      audio.pause();
      audio.currentTime = 0;
      const voiceMsg = document.querySelector(`[data-msg-id="${msgId}"]`);
      if(voiceMsg){
        const playBtn = voiceMsg.querySelector('.voice-play-btn');
        const playIcon = playBtn.querySelector('.play-icon');
        const pauseIcon = playBtn.querySelector('.pause-icon');
        playIcon.style.display = 'block';
        pauseIcon.style.display = 'none';
        bars.forEach(bar => bar.classList.remove('active'));
      }
      currentPlayingAudio = null;
    }
    async function startVoiceRecording(e){
      if(e) e.preventDefault();
      if(!currentChat) {
        showToast('⚠️', 'Ошибка', 'Выберите чат для отправки голосового сообщения');
        return;
      }
      // Если уже идёт запись, игнорируем
      if(mediaRecorder && mediaRecorder.state === 'recording') return;
      try {
        console.log('Requesting microphone access...');
        // Получаем настройки микрофона
        const settings = JSON.parse(localStorage.getItem('flashchat_settings') || '{}');
        // Запрашиваем доступ к микрофону с оптимальными настройками
        const constraints = {
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true,
            sampleRate: 48000
          }
        };
        // Если выбран конкретный микрофон
        if(settings.microphoneId){
          constraints.audio.deviceId = { exact: settings.microphoneId };
        }
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        console.log('Microphone access granted');
        console.log('Audio tracks:', stream.getAudioTracks().length);
        // Проверяем, что трек активен
        const audioTrack = stream.getAudioTracks()[0];
        if(audioTrack){
          console.log('Audio track settings:', audioTrack.getSettings());
          console.log('Audio track enabled:', audioTrack.enabled);
          console.log('Audio track muted:', audioTrack.muted);
        }
        // Определяем поддерживаемый MIME тип
        let mimeType = 'audio/webm';
        if(!MediaRecorder.isTypeSupported('audio/webm')){
          if(MediaRecorder.isTypeSupported('audio/mp4')){
            mimeType = 'audio/mp4';
          } else if(MediaRecorder.isTypeSupported('audio/ogg')){
            mimeType = 'audio/ogg';
          } else if(MediaRecorder.isTypeSupported('audio/wav')){
            mimeType = 'audio/wav';
          }
        }
        console.log('Using MIME type:', mimeType);
        mediaRecorder = new MediaRecorder(stream, { mimeType });
        audioChunks = [];
        mediaRecorder.ondataavailable = (e) => {
          console.log('📊 Data available:', e.data.size, 'bytes, type:', e.data.type);
          if(e.data.size > 0){
            audioChunks.push(e.data);
            console.log('✅ Chunk added. Total chunks:', audioChunks.length);
          } else {
            console.warn('⚠️ Empty chunk received');
          }
        };
        mediaRecorder.onstop = async () => {
          console.log('🛑 Recording stopped');
          console.log('Total chunks:', audioChunks.length);
          // Останавливаем все треки
          stream.getTracks().forEach(track => {
            console.log('Stopping track:', track.kind, track.label);
            track.stop();
          });
          if(audioChunks.length === 0){
            console.error('❌ No audio data recorded!');
            showToast('⚠️', 'Ошибка', 'Не удалось записать аудио');
            return;
          }
          // Создаем blob из всех chunks
          const audioBlob = new Blob(audioChunks, { type: mimeType });
          console.log('📦 Audio blob created:');
          console.log('  - Size:', audioBlob.size, 'bytes');
          console.log('  - Type:', audioBlob.type);
          console.log('  - Chunks used:', audioChunks.length);
          // Проверяем размер
          if(audioBlob.size < 100){
            console.error('❌ Audio blob too small:', audioBlob.size);
            showToast('⚠️', 'Ошибка', 'Голосовое сообщение слишком короткое');
            return;
          }
          console.log('✅ Audio blob valid, sending...');
          // Отправляем голосовое сообщение
          await sendVoiceMessage(audioBlob, mimeType);
        };
        mediaRecorder.onerror = (e) => {
          console.error('MediaRecorder error:', e);
          showToast('❌', 'Ошибка', 'Ошибка записи аудио');
        };
        // Запускаем запись с timeslice для регулярного получения данных
        mediaRecorder.start(100); // Получаем данные каждые 100ms
        // haptic feedback on start (if supported)
        try{ if(navigator && navigator.vibrate) navigator.vibrate(20); }catch(e){}
        console.log('Recording started with timeslice 100ms');
        recordingStartTime = Date.now();
        // Показываем индикатор записи
        $('recordingIndicator').classList.remove('hidden');
        $('voiceBtn').style.background = 'rgba(239,68,68,.25)';
        // Обновляем таймер
        updateRecordingTime();
        recordingInterval = setInterval(updateRecordingTime, 1000);
      } catch(err) {
        console.error('Voice recording error:', err);
        if(err.name === 'NotAllowedError'){
          showToast('❌', 'Ошибка', 'Доступ к микрофону запрещён. Разрешите доступ в настройках браузера');
        } else if(err.name === 'NotFoundError'){
          showToast('❌', 'Ошибка', 'Микрофон не найден');
        } else {
          showToast('❌', 'Ошибка', 'Не удалось начать запись: ' + err.message);
        }
      }
    }
    function stopVoiceRecording(e){
      if(e) e.preventDefault();
      console.log('Stopping recording...');
      if(!mediaRecorder || mediaRecorder.state === 'inactive') {
        console.log('No active recording');
        return;
      }
      mediaRecorder.stop();
      clearInterval(recordingInterval);
      $('recordingIndicator').classList.add('hidden');
      $('voiceBtn').style.background = '';
    }
    function cancelRecording(){
      console.log('Cancelling recording...');
      if(!mediaRecorder) return;
      // Останавливаем запись без отправки
      if(mediaRecorder.state !== 'inactive'){
        // Очищаем chunks перед остановкой, чтобы onstop не отправил сообщение
        audioChunks = [];
        mediaRecorder.stop();
        if(mediaRecorder.stream){
          mediaRecorder.stream.getTracks().forEach(track => track.stop());
        }
      }
      clearInterval(recordingInterval);
      $('recordingIndicator').classList.add('hidden');
      $('voiceBtn').style.background = '';
      mediaRecorder = null;
      recordingStartTime = null;
    }
    function updateRecordingTime(){
      if(!recordingStartTime) return;
      const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      $('recordingTime').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }
    async function sendVoiceMessage(audioBlob, mimeType){
      const metaDur = await getBlobAudioDuration(audioBlob);
      const durationStr = normalizeAudioDuration(metaDur);

      console.log('🎤 Sending voice message...');
      if(!currentChat) {
        console.error('No current chat!');
        return;
      }
      // Проверяем бан
      const banSnap = await database.ref(`bannedUsers/${currentUser.uid}`).once('value');
      if(banSnap.exists()){
        showToast('🚫', 'Доступ запрещен', 'Вы заблокированы и не можете отправлять сообщения');
        await auth.signOut();
        return;
      }
      try {
        // Вычисляем длительность
        const duration = Math.floor((Date.now() - recordingStartTime) / 1000);
        const minutes = Math.floor(duration / 60);
        const seconds = duration % 60;
        const durationStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        showToast('⏳', 'Отправка', 'Загрузка голосового сообщения...');
        // Конвертируем blob в base64
        const reader = new FileReader();
        const base64Promise = new Promise((resolve, reject) => {
          reader.onload = () => resolve(reader.result);
          reader.onerror = reject;
          reader.readAsDataURL(audioBlob);
        });
        const base64Data = await base64Promise;
        // Сохраняем файл в Firebase Database
        const fileRef = database.ref('files').push();
        const fileId = fileRef.key;
        await fileRef.set({
          data: base64Data,
          mimeType: mimeType,
          uploadedBy: currentUser.uid,
          uploadedAt: firebase.database.ServerValue.TIMESTAMP
        });
        // Создаём firebase-file:// URL
        const audioUrl = `firebase-file://${fileId}`;
        // Отправляем сообщение
        const msgData = {
          senderId: currentUser.uid,
          timestamp: firebase.database.ServerValue.TIMESTAMP,
          isVoiceMessage: true,
          fileUrl: audioUrl,
          fileType: mimeType,
          fileName: `Голосовое сообщение`,
          audioDuration: durationStr
        };
        // Сохраняем в избранное или обычный чат
        if(currentChatType === 'saved'){
          await database.ref(`savedMessages/${currentUser.uid}`).push(msgData);
        } else {
          await database.ref(`messages/${currentChat}`).push(msgData);
        }
        // Обновляем последнее сообщение в чате (только если не избранное)
        if(currentChatType !== 'saved'){
          await database.ref(`userChats/${currentUser.uid}/${currentChat}`).update({
            lastMessage: '🎤 Голосовое сообщение',
            lastTime: firebase.database.ServerValue.TIMESTAMP
          });
          // Для приватных чатов обновляем и у собеседника
          if(currentChatType === 'private' && currentChatData?.oderId){
            await database.ref(`userChats/${currentChatData.oderId}/${currentChat}`).update({
              lastMessage: '🎤 Голосовое сообщение',
              lastTime: firebase.database.ServerValue.TIMESTAMP
            });
          }
          // Для групп и каналов обновляем у всех участников
          if((currentChatType === 'group' || currentChatType === 'channel') && currentChatData?.members){
            const updates = {};
            for(const memberId of Object.keys(currentChatData.members)){
              if(memberId !== currentUser.uid){
                updates[`userChats/${memberId}/${currentChat}/lastMessage`] = '🎤 Голосовое сообщение';
                updates[`userChats/${memberId}/${currentChat}/lastTime`] = firebase.database.ServerValue.TIMESTAMP;
              }
            }
            if(Object.keys(updates).length > 0){
              await database.ref().update(updates);
            }
          }
        }
        showToast('✅', 'Успешно', 'Голосовое сообщение отправлено');
      } catch(err) {
        console.error('Send voice message error:', err);
        showToast('❌', 'Ошибка', 'Не удалось отправить голосовое сообщение: ' + err.message);
      }
    }
    // Инициализация кнопки записи голоса
    function initVoiceButton(){
      const voiceBtn = $('voiceBtn');
      if(!voiceBtn) return;
      let isRecording = false;
      // Для десктопа
      voiceBtn.addEventListener('mousedown', (e) => {
        e.preventDefault();
        if(!isRecording){
          isRecording = true;
          startVoiceRecording(e);
        }
      });
      voiceBtn.addEventListener('mouseup', (e) => {
        e.preventDefault();
        if(isRecording){
          isRecording = false;
          stopVoiceRecording(e);
        }
      });
      voiceBtn.addEventListener('mouseleave', (e) => {
        if(isRecording){
          isRecording = false;
          stopVoiceRecording(e);
        }
      });
      // Для мобильных устройств
      voiceBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if(!isRecording){
          isRecording = true;
          startVoiceRecording(e);
        }
      });
      voiceBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        if(isRecording){
          isRecording = false;
          stopVoiceRecording(e);
        }
      });
      voiceBtn.addEventListener('touchcancel', (e) => {
        e.preventDefault();
        if(isRecording){
          isRecording = false;
          cancelRecording();
        }
      });
      console.log('Voice button initialized');
    }
    // Инициализация кнопки записи кружков (видео)
    function initCircleButton(){
      const circleBtn = $('circleBtn');
      if(!circleBtn) return;
      const open = (e)=>{
        try{ e.preventDefault(); e.stopPropagation(); }catch(err){}
        openCircleRecorder();
      };
      // click / tap opens TG-like recorder screen
      circleBtn.addEventListener('click', open);
      circleBtn.addEventListener('touchstart', open, {passive:false});
      console.log('Circle button initialized');
    }
    // Переменные для записи кружков

    let circleMediaRecorder;

    let circleChunks = [];
        circleCanceled = false;

    let circleRecordingStartTime;

    let circleRecordingInterval;

    // TG-like circle recorder UI state
    let circlePreviewStream = null;
    let circleFacingMode = 'user'; // 'user' | 'environment'
    var circleCanceled = false;
    let circleTorchOn = false;
    let circleIsCancelGesture = false;
    let circleTouchStartX = null;

    function fmtMMSS(ms){
      const s = Math.max(0, Math.floor(ms/1000));
      const m = Math.floor(s/60);
      const ss = (s%60).toString().padStart(2,'0');
      return `${m}:${ss}`;
    }

    function setCircleOverlayVisible(v){
      const ov = $('circleRecOverlay');
      if(!ov) return;
      ov.classList.toggle('hidden', !v);
      ov.setAttribute('aria-hidden', v ? 'false' : 'true');
    }

    function attachStreamToCircleUI(stream){
      const v = $('circleRecVideo');
      const bg = $('circleRecBg');
      try{
        if(v){ v.srcObject = stream; const p=v.play(); if(p?.catch) p.catch(()=>{}); }
        if(bg){ bg.srcObject = stream; const p2=bg.play(); if(p2?.catch) p2.catch(()=>{}); }
      }catch(e){ console.warn('attach stream failed', e); }
      // mirror only front camera
      if(v){
        v.style.transform = (circleFacingMode === 'user') ? 'scaleX(-1)' : 'none';
      }
    }

    async function openCircleRecorder(){
      if(!currentChat){
        showToast('⚠️', 'Ошибка', 'Выберите чат для отправки кружка');
        return;
      }
      if(circleMediaRecorder && circleMediaRecorder.state === 'recording') return;

      setCircleOverlayVisible(true);

      // request stream (preview)
      try{
        const settings = JSON.parse(localStorage.getItem('flashchat_settings') || '{}');
        const constraints = {
          video: {
            width: { ideal: 720 },
            height:{ ideal: 720 },
            facingMode: circleFacingMode
          },
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          }
        };
        if(settings.cameraId){ constraints.video.deviceId = { exact: settings.cameraId }; }
        if(settings.microphoneId){ constraints.audio.deviceId = { exact: settings.microphoneId }; }

        circlePreviewStream = await navigator.mediaDevices.getUserMedia(constraints);
        attachStreamToCircleUI(circlePreviewStream);

        // reset UI
        $('circleRecTime').textContent = '0:00';
        $('circleRecCancelHint').classList.remove('canceling');
        circleIsCancelGesture = false;
        circleTorchOn = false;

      }catch(err){
        console.error('Circle preview error:', err);
        setCircleOverlayVisible(false);

      // reset UI
      try{
        document.getElementById('circleRecBtn')?.classList.remove('recording');
        var p = document.getElementById('circleRecProgress');
        if(p) p.style.strokeDashoffset = '301.59';
      }catch(e){}
        if(err.name === 'NotAllowedError') showToast('❌','Ошибка','Доступ к камере запрещён');
        else if(err.name === 'NotFoundError') showToast('❌','Ошибка','Камера не найдена');
        else showToast('❌','Ошибка','Не удалось открыть камеру: ' + (err.message||err));
      }
    }

    function closeCircleRecorder(){
      // do not close while recording
      if(circleMediaRecorder && circleMediaRecorder.state === 'recording') return;

      setCircleOverlayVisible(false);
      // stop preview
      if(circlePreviewStream){
        try{ circlePreviewStream.getTracks().forEach(t=>t.stop()); }catch(e){}
        circlePreviewStream = null;
      }
    }

    async function toggleCircleTorch(){
      if(!circlePreviewStream) return;
      var tracks = (circlePreviewStream && circlePreviewStream.getVideoTracks) ? circlePreviewStream.getVideoTracks() : [];
      var track = tracks[0];
      if(!track) return;
      const btn = $('circleRecFlash');
      const caps = track.getCapabilities ? track.getCapabilities() : {};
      if(!caps.torch){
        showToast('⚠️','Вспышка','Вспышка не поддерживается');
        return;
      }
      circleTorchOn = !circleTorchOn;
      try{
        await track.applyConstraints({ advanced: [{ torch: circleTorchOn }] });
        if(btn) btn.classList.toggle('active', circleTorchOn);
      }catch(e){
        circleTorchOn = !circleTorchOn;
        if(btn) btn.classList.toggle('active', circleTorchOn);
        console.warn('torch failed', e);
        showToast('⚠️','Вспышка','Не удалось включить вспышку');
      }
    }

    async function flipCircleCamera(){
      if(circleMediaRecorder && circleMediaRecorder.state === 'recording') return; // keep simple
      circleFacingMode = (circleFacingMode === 'user') ? 'environment' : 'user';
      // restart preview stream
      if(circlePreviewStream){
        try{ circlePreviewStream.getTracks().forEach(t=>t.stop()); }catch(e){}
        circlePreviewStream = null;
      }
      await openCircleRecorder();
    }

    function updateCircleOverlayTime(){
      if(!circleRecordingStartTime) return;
      const t = Date.now() - circleRecordingStartTime;
      const el = $('circleRecTime');
      if(el) el.textContent = fmtMMSS(t);
    }

    function initCircleRecorderOverlay(){
      const ov = $('circleRecOverlay');
      if(!ov) return;
      $('circleRecClose')?.addEventListener('click', ()=>{
        // if recording -> cancel, else just close
        if(circleMediaRecorder && circleMediaRecorder.state === 'recording') cancelCircleRecording();
        else closeCircleRecorder();
      });
      $('circleRecFlip')?.addEventListener('click', flipCircleCamera);
      $('circleRecFlash')?.addEventListener('click', toggleCircleTorch);
      const recBtn = $('circleRecBtn');
      if(!recBtn) return;
      // Tap toggles start/stop (Telegram-like)
      recBtn.addEventListener('click', (e)=>{
        e.preventDefault();
        if(circleMediaRecorder && circleMediaRecorder.state === 'recording'){
          // Second tap = STOP + SEND
          try{ circleCanceled = false; }catch(_e){}
          stopCircleRecording(e);
          recBtn.classList.remove('recording');
        }else{
          // Start recording
          circleIsCancelGesture = false;
          try{ circleCanceled = false; }catch(_e){}
          try{ circleChunks = []; }catch(_e){}
          $('circleRecCancelHint')?.classList.remove('canceling');
          startCircleRecording(e);
          recBtn.classList.add('recording');
        }
      });
      // Swipe left to cancel while recording (touch)
      recBtn.addEventListener('touchstart', (e)=>{
        if(e.cancelable) e.preventDefault();
        circleTouchStartX = (e.touches && e.touches[0]) ? e.touches[0].clientX : null;
        if(!(circleMediaRecorder && circleMediaRecorder.state === 'recording')){
          circleIsCancelGesture = false;
          $('circleRecCancelHint')?.classList.remove('canceling');
          startCircleRecording(e);
          recBtn.classList.add('recording');
        }
      }, {passive:false});
      window.addEventListener('touchmove', (e)=>{
        if(!(circleMediaRecorder && circleMediaRecorder.state === 'recording')) return;
        if(circleTouchStartX == null) return;
        const x = (e.touches && e.touches[0]) ? e.touches[0].clientX : null;
        if(x == null) return;
        const dx = x - circleTouchStartX;
        if(dx < -80){
          circleIsCancelGesture = true;
          $('circleRecCancelHint')?.classList.add('canceling');
        }else{
          circleIsCancelGesture = false;
          $('circleRecCancelHint')?.classList.remove('canceling');
        }
      }, {passive:false});
      window.addEventListener('touchend', (e)=>{
        if(!(circleMediaRecorder && circleMediaRecorder.state === 'recording')) return;
        if(circleIsCancelGesture){
          cancelCircleRecording();
          recBtn.classList.remove('recording');
        }
        circleIsCancelGesture = false;
        circleTouchStartX = null;
        $('circleRecCancelHint')?.classList.remove('canceling');
      }, {passive:false});
    }


function showCircleLivePreview(stream){
  const overlay = $('circlePreviewOverlay');
  const video = $('circlePreviewVideo');
  if(!overlay || !video) return;
  try{
    video.srcObject = stream;
    // Some browsers need explicit play()
    const p = video.play();
    if(p && typeof p.catch === 'function') p.catch(()=>{});
  }catch(e){
    console.warn('Preview attach failed', e);
  }
  overlay.classList.add('show');
}

function hideCircleLivePreview(){
  const overlay = $('circlePreviewOverlay');
  const video = $('circlePreviewVideo');
  if(overlay) overlay.classList.remove('show');
  if(video){
    try{
      video.pause();
      video.srcObject = null;
    }catch(e){}
  }
}

function updateCirclePreviewTime(){
  if(!circleRecordingStartTime) return;
  const elapsed = Math.floor((Date.now() - circleRecordingStartTime) / 1000);
  const minutes = Math.floor(elapsed / 60);
  const seconds = elapsed % 60;
  const t = `${minutes}:${seconds.toString().padStart(2,'0')}`;
  const el = $('circlePreviewTime');
  if(el) el.textContent = t;
}





    async function startCircleRecording(e){

      if(e) e.preventDefault();

      if(!currentChat) {

        showToast('⚠️', 'Ошибка', 'Выберите чат для отправки кружка');

        return;

      }

      

      if(circleMediaRecorder && circleMediaRecorder.state === 'recording') return;

      

      try {

        console.log('Requesting camera and microphone access...');

        

        // Получаем настройки

        const settings = JSON.parse(localStorage.getItem('flashchat_settings') || '{}');

        

        const constraints = {

          video: { 

            width: { ideal: 720 },

            height: { ideal: 720 },

            facingMode: 'user'

          },

          audio: {

            echoCancellation: true,

            noiseSuppression: true,

            autoGainControl: true

          }

        };

        

        // Если выбрана конкретная камера

        if(settings.cameraId){

          constraints.video.deviceId = { exact: settings.cameraId };

        }

        

        // Если выбран конкретный микрофон

        if(settings.microphoneId){

          constraints.audio.deviceId = { exact: settings.microphoneId };

        }

        

        let stream = circlePreviewStream;
        if(!stream){
          stream = await navigator.mediaDevices.getUserMedia(constraints);
          circlePreviewStream = stream;
          attachStreamToCircleUI(stream);
        }
        // ensure overlay is visible during recording
        setCircleOverlayVisible(true);

        

        console.log('Camera access granted');

        

        var mimeType = 'video/webm;codecs=vp8,opus';
        if(typeof MediaRecorder !== 'undefined' && MediaRecorder.isTypeSupported){
          if(!MediaRecorder.isTypeSupported(mimeType) && MediaRecorder.isTypeSupported('video/webm;codecs=vp9,opus')) mimeType = 'video/webm;codecs=vp9,opus';
          if(!MediaRecorder.isTypeSupported(mimeType) && MediaRecorder.isTypeSupported('video/webm;codecs=av1,opus')) mimeType = 'video/webm;codecs=av1,opus';
          if(!MediaRecorder.isTypeSupported(mimeType) && MediaRecorder.isTypeSupported('video/webm')) mimeType = 'video/webm';
        }
        console.log('Using MIME type:', mimeType);
        circleMediaRecorder = new MediaRecorder(stream, { mimeType: mimeType });

        circleChunks = [];

        

        circleMediaRecorder.ondataavailable = (e) => {

          if(e.data.size > 0){

            circleChunks.push(e.data);

          }

        };

        

        circleMediaRecorder.onstop = async () => {
          console.log('Circle recording stopped');
          try{
            // stop tracks after recorder finalized
            if(stream){ stream.getTracks().forEach(function(track){ try{ track.stop(); }catch(e){} }); }
          }catch(e){}
          if(circlePreviewStream){
            try{ circlePreviewStream.getTracks().forEach(function(t){ try{ t.stop(); }catch(e){} }); }catch(e){}
            circlePreviewStream = null;
          }
          if(circleCanceled){
            // canceled by user
            circleChunks = [];
            return;
          }
          if(!circleChunks || circleChunks.length === 0){
            showToast('⚠️', 'Ошибка', 'Не удалось записать видео');
            circleMediaRecorder = null;
            circleRecordingStartTime = null;
            closeCircleRecorder();
            return;
          }
          var videoBlob = new Blob(circleChunks, { type: mimeType });
          console.log('Video blob size:', videoBlob.size);
          if(videoBlob.size < 1500){
            showToast('⚠️', 'Ошибка', 'Кружок слишком короткий');
            circleMediaRecorder = null;
            circleRecordingStartTime = null;
            closeCircleRecorder();
            return;
          }
          try{
            await sendCircleMessage(videoBlob, mimeType);
          }finally{
            circleMediaRecorder = null;
            circleRecordingStartTime = null;
            closeCircleRecorder();
          }
        };

        

        circleMediaRecorder.start();

        // haptic feedback on start (if supported)
        try{ if(navigator && navigator.vibrate) navigator.vibrate(25); }catch(e){}


        circleRecordingStartTime = Date.now();
        updateCircleRecordingTime();

        circleRecordingInterval = setInterval(updateCircleRecordingTime, 1000);

        

      } catch(err) {

        console.error('Circle recording error:', err);

        if(err.name === 'NotAllowedError'){

          showToast('❌', 'Ошибка', 'Доступ к камере запрещён');

        } else if(err.name === 'NotFoundError'){

          showToast('❌', 'Ошибка', 'Камера не найдена');

        } else {

          showToast('❌', 'Ошибка', 'Не удалось начать запись: ' + err.message);

        }

      }

    }



    function stopCircleRecording(e){
      if(e) e.preventDefault();
      if(!circleMediaRecorder || circleMediaRecorder.state === 'inactive') return;
      try{ if(circleMediaRecorder.requestData) circleMediaRecorder.requestData(); }catch(err){}
      // Let onstop handle stream cleanup to avoid empty chunks on some devices
      clearInterval(circleRecordingInterval);
      circleMediaRecorder.stop();
      // keep overlay until onstop, but freeze hint
      setCircleOverlayVisible(false);
    }



    function cancelCircleRecording(){

      if(!circleMediaRecorder) return;

      

      if(circleMediaRecorder.state !== 'inactive'){

        circleCanceled = true;
        try{ if(circleMediaRecorder.requestData) circleMediaRecorder.requestData(); }catch(e){}
        circleMediaRecorder.stop();
        setCircleOverlayVisible(false);

        if(circleMediaRecorder.stream){

          circleMediaRecorder.stream.getTracks().forEach(track => track.stop());

        }

      }

      

      clearInterval(circleRecordingInterval);
      circleMediaRecorder = null;

      circleRecordingStartTime = null;
       closeCircleRecorder();

    }



    
    
function updateCircleRecordingTime(){
  if(!circleRecordingStartTime) return;
  var elapsed = Math.floor((Date.now() - circleRecordingStartTime) / 1000);
  var minutes = Math.floor(elapsed / 60);
  var seconds = elapsed % 60;
  var secStr = (seconds < 10 ? "0" + seconds : seconds);
  var t = minutes + ":" + secStr;
  var rt = document.getElementById('recordingTime');
  if(rt) rt.textContent = t;
  var ct = document.getElementById('circleRecTime');
  if(ct) ct.textContent = t;

  // visual progress arc (fills up to 60s like Telegram circles)
  try{
    var p = document.getElementById('circleRecProgress');
    if(p){
      var ratio = Math.min(elapsed / 60, 1);
      var circ = 301.59; // 2*pi*48
      p.style.strokeDashoffset = String(circ * (1 - ratio));
    }
  }catch(e){}

  var pt = document.getElementById('circlePreviewTime');
  if(pt) pt.textContent = t;
}
    async function sendCircleMessage(videoBlob, mimeType){

      console.log('Sending circle message...');

      

      if(!currentChat) return;

      

      // Проверяем бан

      const banSnap = await database.ref(`bannedUsers/${currentUser.uid}`).once('value');

      if(banSnap.exists()){

        showToast('🚫', 'Доступ запрещен', 'Вы заблокированы и не можете отправлять сообщения');

        await auth.signOut();

        return;

      }

      

      try {

        const duration = Math.floor((Date.now() - circleRecordingStartTime) / 1000);

        

        showToast('⏳', 'Отправка', 'Загрузка кружка...');

        

        // Конвертируем blob в base64

        const reader = new FileReader();

        const base64Promise = new Promise((resolve, reject) => {

          reader.onload = () => resolve(reader.result);

          reader.onerror = reject;

          reader.readAsDataURL(videoBlob);

        });

        

        const base64Data = await base64Promise;

        

        // Сохраняем файл в Firebase Database

        const fileRef = database.ref('files').push();

        const fileId = fileRef.key;

        

        await fileRef.set({

          data: base64Data,

          mimeType: mimeType,

          uploadedBy: currentUser.uid,

          uploadedAt: firebase.database.ServerValue.TIMESTAMP

        });

        

        // Создаём firebase-file:// URL

        const videoUrl = `firebase-file://${fileId}`;

        

        const msgData = {

          senderId: currentUser.uid,

          timestamp: firebase.database.ServerValue.TIMESTAMP,

          isVideoMessage: true,

          fileUrl: videoUrl,

          fileType: mimeType,

          fileName: 'Кружок',

          isCircle: true

        };

        

        // Сохраняем в избранное или обычный чат

        if(currentChatType === 'saved'){

          await database.ref(`savedMessages/${currentUser.uid}`).push(msgData);

        } else {

          await database.ref(`messages/${currentChat}`).push(msgData);

        }

        

        // Обновляем последнее сообщение в чате (только если не избранное)

        if(currentChatType !== 'saved'){

          await database.ref(`userChats/${currentUser.uid}/${currentChat}`).update({

            lastMessage: '🎥 Кружок',

            lastTime: firebase.database.ServerValue.TIMESTAMP

          });

          

          if(currentChatType === 'private' && currentChatData?.oderId){

            await database.ref(`userChats/${currentChatData.oderId}/${currentChat}`).update({

              lastMessage: '🎥 Кружок',

              lastTime: firebase.database.ServerValue.TIMESTAMP

            });

          }

          

          // Для групп и каналов обновляем у всех участников

          if((currentChatType === 'group' || currentChatType === 'channel') && currentChatData?.members){

            const updates = {};

            for(const memberId of Object.keys(currentChatData.members)){

              if(memberId !== currentUser.uid){

                updates[`userChats/${memberId}/${currentChat}/lastMessage`] = '🎥 Кружок';

                updates[`userChats/${memberId}/${currentChat}/lastTime`] = firebase.database.ServerValue.TIMESTAMP;

              }

            }

            if(Object.keys(updates).length > 0){

              await database.ref().update(updates);

            }

          }

        }

        

        showToast('✅', 'Успешно', 'Кружок отправлен');

        

      } catch(err) {

        console.error('Send circle error:', err);

        showToast('❌', 'Ошибка', 'Не удалось отправить кружок');

      }

    }



    // ====== INIT ======

    loadSavedAccounts();

    renderEmojiCategory('smileys');

    

    // Загружаем и применяем тему

    const savedSettings = JSON.parse(localStorage.getItem('flashchat_settings') || '{}');

    const theme = savedSettings.theme || 'dark';

    applyTheme(theme);

    

    // Слушаем изменения системной темы для режима "авто"

    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {

      const settings = JSON.parse(localStorage.getItem('flashchat_settings') || '{}');

      if(settings.theme === 'auto'){

        applyTheme('auto');

      }

    });

    

    // Инициализируем кнопки после загрузки DOM

    document.addEventListener('DOMContentLoaded', () => {
      initVoiceButton();
      initCircleRecorderOverlay();
      initCircleButton();
    });
    // Если DOM уже загружен
    if(document.readyState === 'complete' || document.readyState === 'interactive'){
      setTimeout(() => {
        initVoiceButton();
        initCircleRecorderOverlay();
        initCircleButton();
      }, 100);
    }
    // ====== MENU ACTIONS: REPLY / FORWARD ======
    async function startReplyFromMenu(){
      try{ hideMessageContextMenu(); }catch(e){}
      if(!currentMessageId || !currentChat) return;
      const messagePath = currentChatType === 'saved'
        ? `savedMessages/${currentUser.uid}/${currentMessageId}`
        : `messages/${currentChat}/${currentMessageId}`;
      try{
        const snap = await database.ref(messagePath).once('value');
        const msg = snap.val();
        if(!msg) return;
        setReplyTo(currentMessageId, msg);
        try{ $('messageInput').focus(); }catch(e){}
      }catch(err){
        console.error('reply from menu error', err);
      }
    }
    let forwardSourceMsg = null; // {id, data}
    function startForwardFromMenu(){
      try{ hideMessageContextMenu(); }catch(e){}
      if(!currentMessageId || !currentChat) return;
      // сохраняем id, подгрузим данные на отправку
      forwardSourceMsg = { id: currentMessageId, data: null };
      try{ $('forwardSearch').value = ''; }catch(e){}
      renderForwardList();
      showModal('forwardModal');
    }
    function renderForwardList(){
      const listEl = $('forwardList');
      if(!listEl) return;
      const q = ($('forwardSearch')?.value || '').toLowerCase().trim();
      const items = [
        { id: '__saved__', type: 'saved', name: 'Избранное', desc: 'Сохраненные сообщения', avatar: '★' },
        ...allChats.map(c => ({ id: c.id, type: c.type, name: c.name, desc: c.lastMessage || '', avatar: c.avatar || '?' }))
      ].filter(item => {
        if(!q) return true;
        const hay = `${item.name||''} ${item.desc||''}`.toLowerCase();
        return hay.includes(q);
      });
      if(!items.length){
        listEl.innerHTML = `<div class="p-6 text-center text-slate-500">Ничего не найдено</div>`;
        return;
      }
      listEl.innerHTML = items.map(item => {
        const gradientClass = item.type === 'group' ? 'gradient-green' : item.type === 'channel' ? 'gradient-orange' : 'gradient-bg';
        const title = item.id === '__saved__' ? 'Избранное' : escapeHtml(item.name || 'Чат');
        const subtitle = item.id === '__saved__' ? 'Сохраненные сообщения' : escapeHtml(item.desc || '');
        return `
          <div class="flex items-center gap-3 p-3 cursor-pointer hover:bg-white/5 transition"
               onclick="selectForwardTarget('${item.id}','${item.type}')">
            <div class="chat-avatar ${gradientClass}">${escapeHtml(item.avatar || '?')}</div>
            <div class="flex-1 min-w-0">
              <div class="font-medium truncate">${title}</div>
              <div class="text-xs text-slate-400 truncate">${subtitle}</div>
            </div>
            <div class="text-xs text-slate-400">→</div>
          </div>
        `;
      }).join('');
    }
    function selectForwardTarget(targetId, targetType){
      // targetId: '__saved__' or chatId
      sendForwardToTarget(targetId, targetType);
    }
    async function sendForwardToTarget(targetId, targetType){
      if(!forwardSourceMsg?.id || !currentChat) return;
      const srcId = forwardSourceMsg.id;
      const srcPath = currentChatType === 'saved'
        ? `savedMessages/${currentUser.uid}/${srcId}`
        : `messages/${currentChat}/${srcId}`;
      try{
        const snap = await database.ref(srcPath).once('value');
        const msg = snap.val();
        if(!msg){
          showToast('❌','Ошибка','Сообщение не найдено');
          return;
        }
        const senderName = allUsers[msg.senderId]?.name || 'Пользователь';
        const base = {
          senderId: currentUser.uid,
          timestamp: firebase.database.ServerValue.TIMESTAMP,
          readBy: { [currentUser.uid]: true },
          forwardedFrom: {
            chatId: currentChat,
            senderId: msg.senderId || null,
            senderName: senderName
          }
        };
        // переносим основные поля контента
        if(msg.text) base.text = msg.text;
        if(msg.fileUrl) base.fileUrl = msg.fileUrl;
        if(msg.fileName) base.fileName = msg.fileName;
        if(msg.fileType) base.fileType = msg.fileType;
        if(msg.voiceFileId) base.voiceFileId = msg.voiceFileId;
        if(msg.voiceDuration) base.voiceDuration = msg.voiceDuration;
        if(msg.circleVideoId) base.circleVideoId = msg.circleVideoId;
        if(msg.circleVideoDuration) base.circleVideoDuration = msg.circleVideoDuration;
        if(targetId === '__saved__'){
          await database.ref(`savedMessages/${currentUser.uid}`).push(base);
        } else {
          await database.ref(`messages/${targetId}`).push(base);
          await touchChatUpdatedAt(targetId);
        }
        closeModal('forwardModal');
        showToast('✅','Успешно','Сообщение переслано');
      }catch(err){
        console.error('forward error', err);
        showToast('❌','Ошибка','Не удалось переслать сообщение');
      }
    }

/* ===== Patch: TG-like overlays + reliable cancel for voice/circle ===== */
(function(){
  const $id=(id)=>document.getElementById(id);
  let voiceCanceled=false,circleCanceled=false;
  let activeCapture=null; // 'voice' | 'circle' | null
  let circleStream=null;
  let circleFacing='user';
  const circleOverlay=$id('tgCircleOverlay');
  const circleVideo=$id('tgCircleVideo');
  const circleTimeEl=$id('tgCircleTime');
  const voiceOverlay=$id('tgVoiceOverlay');
  const voiceTimeEl=$id('tgVoiceTime');
  function fmt(sec){sec=Math.max(0,sec|0);const m=(sec/60)|0;const s=sec%60;return `${m}:${String(s).padStart(2,'0')}`;}
  // ---- Voice UI
  const _origUpdateRecordingTime=window.updateRecordingTime;
  window.updateRecordingTime=function(){
    try{ if(window.recordingStartTime){ voiceTimeEl.textContent=fmt((Date.now()-window.recordingStartTime)/1000); } }catch(e){}
    if(typeof _origUpdateRecordingTime==='function') return _origUpdateRecordingTime.apply(this,arguments);
  };
  function showVoiceUI(){ if(voiceOverlay){ voiceOverlay.classList.add('show'); voiceOverlay.setAttribute('aria-hidden','false'); } }
  function hideVoiceUI(){ if(voiceOverlay){ voiceOverlay.classList.remove('show'); voiceOverlay.setAttribute('aria-hidden','true'); } }
  // ---- Circle UI
  function showCircleUI(){ if(circleOverlay){ circleOverlay.classList.add('show'); circleOverlay.setAttribute('aria-hidden','false'); } }
  function hideCircleUI(){ if(circleOverlay){ circleOverlay.classList.remove('show'); circleOverlay.setAttribute('aria-hidden','true'); } }
  function setCircleTime(){ try{ if(window.circleRecordingStartTime){ circleTimeEl.textContent=fmt((Date.now()-window.circleRecordingStartTime)/1000); } }catch(e){} }
  // Override updateCircleRecordingTime to also update overlay
  const _origUpdateCircle=window.updateCircleRecordingTime;
  window.updateCircleRecordingTime=function(){ setCircleTime(); if(typeof _origUpdateCircle==='function') return _origUpdateCircle.apply(this,arguments); };
  // Cancel by swipe left on overlays
  function bindSwipeCancel(el,cancelFn){
    if(!el) return;
    let sx=0,sy=0,active=false;
    el.addEventListener('touchstart', (e)=>{ if(e.touches&&e.touches[0]){ sx=e.touches[0].clientX; sy=e.touches[0].clientY; active=true; } }, {passive:true});
    el.addEventListener('touchmove', (e)=>{
      if(!active||!e.touches||!e.touches[0]) return;
      const dx=e.touches[0].clientX-sx, dy=e.touches[0].clientY-sy;
      if(dx<-80 && Math.abs(dy)<60){ active=false; cancelFn(); }
    }, {passive:true});
    el.addEventListener('touchend', ()=>{active=false;},{passive:true});
  }
  bindSwipeCancel(circleOverlay, ()=>window.cancelCircleRecording && window.cancelCircleRecording());
  bindSwipeCancel(voiceOverlay, ()=>window.cancelRecording && window.cancelRecording());
  // Buttons
  const vCancel=$id('tgVoiceCancel'); if(vCancel){ vCancel.onclick=(e)=>{e.preventDefault();e.stopPropagation(); window.cancelRecording && window.cancelRecording();}; }
  const cCancel=$id('tgCircleCancel'); if(cCancel){ cCancel.onclick=(e)=>{e.preventDefault();e.stopPropagation(); window.cancelCircleRecording && window.cancelCircleRecording();}; }
  const cFlip=$id('tgCircleFlip');
  if(cFlip){
    cFlip.onclick=(e)=>{
      e.preventDefault();e.stopPropagation();
      circleFacing = (circleFacing==='user') ? 'environment' : 'user';
      
      try{
        if(circleVideo){
          circleVideo.style.transform = (circleFacing==='user') ? 'scaleX(-1)' : 'none';
        }
      }catch(e){}
// If currently recording circle, restart stream preview only (recorder keeps existing stream; simplest: ignore during recording)
      if(activeCapture==='circle' && circleMediaRecorder && circleMediaRecorder.state==='recording') return;
    };
  }
  // ---- Patch start/stop/cancel voice to prevent circle overlay and prevent sending on cancel
  const _origStartVoice=window.startVoiceRecording;
  window.startVoiceRecording=function(e){
    if(activeCapture==='circle') return; // don't mix
    voiceCanceled=false; activeCapture='voice';
    showVoiceUI();
    return _origStartVoice ? _origStartVoice.call(this,e) : undefined;
  };
  const _origStopVoice=window.stopVoiceRecording;
  window.stopVoiceRecording=function(e){
    const r=_origStopVoice ? _origStopVoice.call(this,e) : undefined;
    // hide UI when recorder stops (onstop may be async)
    setTimeout(()=>{ if(activeCapture==='voice'){ hideVoiceUI(); activeCapture=null; } }, 50);
    return r;
  };
  const _origCancel=window.cancelRecording;
  window.cancelRecording=function(){
    voiceCanceled=true;
    hideVoiceUI();
    activeCapture=null;
    return _origCancel ? _origCancel.call(this) : undefined;
  };
  // Wrap mediaRecorder.onstop to honor voiceCanceled (if recorder exists)
  const _hookVoiceOnStop=()=>{
    try{
      if(!window.mediaRecorder) return;
      const mr=window.mediaRecorder;
      const prev=mr.onstop;
      mr.onstop = function(){
        try{ if(voiceCanceled){ hideVoiceUI(); activeCapture=null; return; } }catch(e){}
        return prev ? prev.apply(this,arguments) : undefined;
      };
    }catch(e){}
  };
  // ---- Patch circle recording to show TG overlay with live preview and reliable cancel
  const _origStartCircle=window.startCircleRecording;
  window.startCircleRecording=function(e){
    if(activeCapture==='voice') return;
    circleCanceled=false; activeCapture='circle';
    showCircleUI();
    // call original, but also try to hook the stream to preview when it exists
    const p=_origStartCircle ? _origStartCircle.call(this,e) : undefined;
    // Attempt to attach current recorder stream to video when available
    setTimeout(()=>{
      try{
        if(window.circleMediaRecorder && window.circleMediaRecorder.stream && circleVideo){
          circleVideo.srcObject = window.circleMediaRecorder.stream;
          circleVideo.play().catch(()=>{});
          
          try{
            // Mirror selfie preview like Telegram
            circleVideo.style.transform = (typeof circleFacing!=='undefined' && circleFacing==='user') ? 'scaleX(-1)' : 'none';
          }catch(e){}
setCircleTime();
        }
      }catch(err){}
    },150);
    // hook onstop to hide overlay & respect cancel
    setTimeout(()=>{
      try{
        const cr=window.circleMediaRecorder;
        if(!cr) return;
        const prev=cr.onstop;
        cr.onstop = async function(){
          try{
            if(circleVideo && circleVideo.srcObject){ const st=circleVideo.srcObject; if(st&&st.getTracks){ st.getTracks().forEach(t=>t.stop()); } }
            circleVideo && (circleVideo.srcObject=null);
          }catch(e){}
          hideCircleUI();
          activeCapture=null;
          if(circleCanceled){ return; }
          return prev ? prev.apply(this,arguments) : undefined;
        };
      }catch(e){}
    },200);
    return p;
  };
  const _origStopCircle=window.stopCircleRecording;
  window.stopCircleRecording=function(e){
    const r=_origStopCircle ? _origStopCircle.call(this,e) : undefined;
    setTimeout(()=>{ hideCircleUI(); activeCapture=null; }, 50);
    return r;
  };
  const _origCancelCircle=window.cancelCircleRecording;
  window.cancelCircleRecording=function(){
    circleCanceled=true;
    hideCircleUI();
    activeCapture=null;
    try{ if(circleVideo && circleVideo.srcObject){ const st=circleVideo.srcObject; st.getTracks().forEach(t=>t.stop()); circleVideo.srcObject=null; } }catch(e){}
    return _origCancelCircle ? _origCancelCircle.call(this) : undefined;
  };
  // ensure init buttons run after patch (in case called earlier, it's fine)
  try{ if(typeof window.initVoiceButton==='function') window.initVoiceButton(); }catch(e){}
  try{ if(typeof window.initCircleButton==='function') window.initCircleButton(); }catch(e){}
})();

</script>
    <!-- Forward Message Modal -->
    <div id="forwardModal" class="modal" onclick="modalBackdropClose(event,'forwardModal')">
      <div class="sheet bottom">
        <div class="p-4 border-b" style="border-color: var(--border)">
          <div class="flex items-center justify-between">
            <div class="font-semibold text-lg">Переслать сообщение</div>
            <button class="icon-btn" onclick="closeModal('forwardModal')" title="Закрыть">
              <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
            </button>
          </div>
          <div class="mt-3">
            <input id="forwardSearch" class="w-full bg-white/5 border border-white/10 rounded-xl px-4 py-2.5 outline-none focus:border-violet-500 text-sm" placeholder="Поиск чатов..." oninput="renderForwardList()">
          </div>
        </div>
        <div class="p-2">
          <div id="forwardList" class="max-h-[65vh] overflow-auto scrollbar"></div>
        </div>
      </div>
    </div>

<!-- ===== TG-like Circle Recorder Overlay ===== -->
<div id="circleRecOverlay" class="circle-rec-overlay hidden" aria-hidden="true">
  <video id="circleRecBg" class="circle-rec-bg" muted playsinline></video>

  <div class="circle-rec-top">
    <button id="circleRecClose" class="circle-rec-iconbtn" type="button" aria-label="Закрыть">✕</button>
  </div>

  <div class="circle-rec-center">

    <svg class="circle-rec-progress" viewBox="0 0 100 100" aria-hidden="true">
      <circle class="crp-track" cx="50" cy="50" r="48"></circle>
      <circle id="circleRecProgress" class="crp-bar" cx="50" cy="50" r="48"></circle>
    </svg>

    <div class="circle-rec-ring" aria-hidden="true"></div>
    <div class="circle-rec-circle">
      <video id="circleRecVideo" muted playsinline></video>
    </div>
  </div>

  <div class="circle-rec-bottom">
    <div class="circle-rec-actions">
      <button id="circleRecFlip" class="circle-rec-iconbtn" type="button" aria-label="Сменить камеру">⟲</button>
      <button id="circleRecFlash" class="circle-rec-iconbtn" type="button" aria-label="Вспышка">⚡</button>
    </div>

    <div class="circle-rec-hint">
      <div class="circle-rec-time" id="circleRecTime">0:00</div>
      <div class="circle-rec-cancel" id="circleRecCancelHint">‹ Влево — отмена</div>
    </div>

    <div class="circle-rec-recbtn-wrap">
      <button id="circleRecBtn" class="circle-rec-recbtn" type="button" aria-label="Запись">
        <span class="circle-rec-recinner"></span>
      </button>
    </div>
  </div>
</div>

<div id="tgVoiceOverlay" aria-hidden="true">
  <div id="tgVoiceBar">
    <div id="tgVoiceDot"></div>
    <div id="tgVoiceTime">0:00</div>
    <div id="tgVoiceWave"><i></i><i></i><i></i><i></i><i></i></div>
    <div id="tgVoiceHint">‹ Влево — отмена</div>
    <button id="tgVoiceCancel">Отмена</button>
  </div>
</div>


<script>
(function(){
  function attachSwipeUpSend(){
    const btn = document.querySelector('.circle-rec-recbtn');
    if(!btn) return;
    let startY = 0;
    let sending = false;
    const THRESHOLD = 60;

    btn.addEventListener('pointerdown', (e)=>{
      sending = false;
      startY = e.clientY || (e.touches && e.touches[0]?.clientY) || 0;
      btn.setPointerCapture?.(e.pointerId);
    });

    btn.addEventListener('pointermove', (e)=>{
      if(startY === 0 || sending) return;
      const y = e.clientY || (e.touches && e.touches[0]?.clientY) || 0;
      const dy = y - startY;
      if(dy < -THRESHOLD){
        sending = true;
        btn.classList.add('sending');
        // trigger same behavior as releasing button (send)
        try{
          btn.dispatchEvent(new PointerEvent('pointerup', {bubbles:true}));
        }catch(err){
          btn.click();
        }
        setTimeout(()=>{
          btn.classList.remove('sending');
          startY = 0;
        }, 200);
      }
    });

    btn.addEventListener('pointerup', ()=>{ startY = 0; sending = false; });
    btn.addEventListener('pointercancel', ()=>{ startY = 0; sending = false; });
  }

  // try multiple times in case overlay is dynamic
  const obs = new MutationObserver(()=>attachSwipeUpSend());
  obs.observe(document.documentElement, {childList:true, subtree:true});
  window.addEventListener('load', attachSwipeUpSend);
})();
</script>


<script>
(function(){
  const $ = (id)=>document.getElementById(id);

  function setCircleTransform(y){
    const center = $('circleRecOverlay')?.querySelector('.circle-rec-center');
    if(!center) return;
    const nodes = [
      center.querySelector('.circle-rec-progress'),
      center.querySelector('.circle-rec-ring'),
      center.querySelector('.circle-rec-circle'),
    ].filter(Boolean);
    nodes.forEach(n=>{ n.style.transform = `translateY(${y}px)`; });
  }

  function resetCircleTransform(){
    setCircleTransform(0);
    const center = $('circleRecOverlay')?.querySelector('.circle-rec-center');
    center?.classList.remove('send-armed');
  }

  function attachDragUpToSend(){
    const ov = $('circleRecOverlay');
    if(!ov) return;
    const center = ov.querySelector('.circle-rec-center');
    const circle = ov.querySelector('.circle-rec-circle');
    const recBtn = $('circleRecBtn'); // existing button that starts/stops
    if(!center || !circle || !recBtn) return;

    let startY = null;
    let active = false;
    let sent = false;
    const ARM_THRESHOLD = 90;   // start "armed"
    const SEND_THRESHOLD = 140; // send when released beyond this
    const MAX_PULL = 210;

    function isRecording(){
      return (window.circleMediaRecorder && window.circleMediaRecorder.state === 'recording');
    }

    circle.addEventListener('pointerdown', (e)=>{
      if(!isRecording()) return;
      active = true;
      sent = false;
      startY = e.clientY;
      center.classList.add('dragging');
      try{ circle.setPointerCapture(e.pointerId); }catch(_){}
    });

    circle.addEventListener('pointermove', (e)=>{
      if(!active || startY == null) return;
      if(!isRecording()) { active=false; resetCircleTransform(); return; }
      const dy = e.clientY - startY;
      const pull = Math.max(-MAX_PULL, Math.min(0, dy)); // only up
      setCircleTransform(pull);

      if(Math.abs(pull) > ARM_THRESHOLD) center.classList.add('send-armed');
      else center.classList.remove('send-armed');
    });

    function finish(e){
      if(!active) return;
      active = false;
      center.classList.remove('dragging');

      if(!isRecording()){
        resetCircleTransform();
        startY = null;
        return;
      }

      const endY = (e && e.clientY != null) ? e.clientY : startY;
      const dy = endY - startY;
      const pull = Math.max(-MAX_PULL, Math.min(0, dy));

      if(Math.abs(pull) >= SEND_THRESHOLD && !sent){
        sent = true;
        // Send the circle into chat: stop recording normally (onstop will sendCircleMessage)
        try{
          recBtn.click();
        }catch(_){
          // fallback if click fails
          recBtn.dispatchEvent(new MouseEvent('click', {bubbles:true}));
        }
      }

      // animate back
      resetCircleTransform();
      startY = null;
    }

    circle.addEventListener('pointerup', finish);
    circle.addEventListener('pointercancel', finish);
  }

  // observe dynamic init
  const mo = new MutationObserver(()=>attachDragUpToSend());
  mo.observe(document.documentElement, {subtree:true, childList:true});
  window.addEventListener('load', attachDragUpToSend);
})();
</script>

</body>
</html>
